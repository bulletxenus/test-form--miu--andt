type Query {
  # Получить язык по ID
  language(id: ID): Languages

  # Получить лимит по ID
  accountLimit(id: ID): AccountLimit

  # Получить лимит по ID
  accountReachedLimit(id: ID): AccountReachedLimit

  # Получить аккаунт по ID
  account(id: ID): Accounts

  # Получить список account states
  accountStates(
    orderBy: [QueryAccountStatesOrderByOrderByClause!]
  ): [AccountState!]!

  # Получить список клиентов
  clientList(group_type: ID!): [Client!]!

  # Получить пользователя  по ID
  applicantIndividual(id: ID): ApplicantIndividual

  # Вывод списка овнеров для компаний
  owners(orderBy: [QueryOwnersOrderByOrderByClause!]): [ApplicantIndividual!]!

  # Получить пользователя  по ID
  applicantCompany(id: ID): ApplicantCompany

  # Получить метку по ID
  applicantCompanyLabel(id: ID): ApplicantCompanyLabel

  # Получить все метки
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantCompanyLabels(
    company_id: ID
    where: QueryApplicantCompanyLabelsWhereWhereConditions
    orderBy: [QueryApplicantCompanyLabelsOrderByOrderByClause!]
  ): [ApplicantCompanyLabel!]!

  # Получить заметку  по ID
  applicantCompanyNote(id: ID): ApplicantCompanyNotes

  # Получить уровень риска по ID
  applicantCompanyRiskLevel(id: ID): ApplicantCompanyRiskLevel

  # Получить должность по ID
  applicantIndividualCompanyPosition(id: ID): ApplicantIndividualCompanyPosition

  # Получить по ID
  applicantIndividualCompanyRelation(id: ID): ApplicantIndividualCompanyRelation

  # Получить уровень риска по ID
  applicantIndividualRiskLevel(id: ID): ApplicantIndividualRiskLevel

  # Получить уровень KYC по  ID
  applicantKycLevel(id: ID): ApplicantKycLevel

  # Получить метку по ID
  applicantIndividualLabel(id: ID): ApplicantIndividualLabel

  # Получить все метки
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantIndividualLabels(
    applicant_id: ID
    where: QueryApplicantIndividualLabelsWhereWhereConditions
    orderBy: [QueryApplicantIndividualLabelsOrderByOrderByClause!]
  ): [ApplicantIndividualLabel!]!

  # Получить модуль по ID
  applicant_module(id: ID): ApplicantModules

  # Получить заметку  по ID
  applicantIndividualNote(id: ID): ApplicantIndividualNotes

  # Получить уровень риска по  ID
  applicantRiskLevel(id: ID): ApplicantRiskLevel

  # Получить состояние по ID
  applicantState(id: ID): ApplicantState

  # Получить причину по ID
  applicantStateReason(id: ID): ApplicantStateReason

  # Получить статутс по ID
  applicantStatus(id: ID): ApplicantStatus

  # Получить по ID
  businessActivity(id: ID): BusinessActivity

  # Получить прайс по ID
  commissionPriceList(id: ID): CommissionPriceList

  # Получить шаблон по ID
  commissionTemplate(id: ID): CommissionTemplate

  # Получить лимит по ID
  commissionTemplateLimit(id: ID): CommissionTemplateLimit

  # Получить по ID
  commissionTemplateLimitPeriod(id: ID): CommissionTemplateLimitPeriod

  # Получить по ID
  commissionTemplateLimitTransferDirection(
    id: ID
  ): CommissionTemplateLimitTransferDirection

  # Получить по ID
  commissionTemplateLimitType(id: ID): CommissionTemplateLimitType

  # Получить компанию по ID
  company(id: ID): Companies

  # Получить настройки компании по ID компании
  companySettings(company_id: ID): CompanySettings
  country(id: ID): Country

  # Получить валюту по ID
  currency(id: ID): Currencies

  # Получить департамент по его ID
  department(id: ID): Departments

  # Получить должность по ID
  departmentPosition(id: ID): DepartmentPosition

  # Получить email notification
  emailNotification(
    company_id: ID!
    group_role_id: ID!
    group_type_id: ID!
    client_id: ID
  ): EmailNotification

  # Получить по smtp setting по ID
  emailSmtp(id: ID!): EmailSmtp

  # Получить список smtp настроек для компании
  emailSmtps(
    company_id: ID!
    orderBy: [QueryEmailSmtpsOrderByOrderByClause!]
  ): [EmailSmtp!]!

  # Получить по билет ID
  emailTemplateLayout(company_id: ID): EmailTemplateLayout

  # Получить по билет ID
  emailTemplate(id: ID): EmailTemplate

  # Получить список  периодов комиссий
  feePeriods: [FeePeriod!]!

  # Получить список статусов
  feeTypes: [FeeType!]!

  # Получить список режимов
  feesModes: [FeesMode!]!

  # Получить файл по ID
  file(id: ID): Files

  # Получить группу по ID
  group_type(id: ID): GroupType

  # Получить список типов групп
  group_types(mode: GroupTypeMode): [GroupType!]!

  # Получить участника по ID
  memberAccessLimitation(id: ID): MemberAccessLimitation

  # Получить участника по ID
  member(id: ID): Members

  # Получить список типов операций
  operationTypes(
    where: QueryOperationTypesWhereWhereConditions
  ): [OperationType!]!

  # Получить провайдер по ID
  paymentProvider(id: ID): PaymentProvider

  # Получить список статусов
  paymentStatuses: [PaymentStatus!]!

  # Получить платежную систем по ID
  paymentSystem(id: ID): PaymentSystem

  # Получить список
  getPaymentTypes: [PaymentTypes!]!

  # Получить список
  getPaymentUrgencys: [PaymentUrgency!]!
  senders: [Sender]

  # Получить платеж по ID
  payment(id: ID): Payments

  # Получить разрешение по ID
  permission(id: ID): Permissions

  # Получить список разрешений
  permissions_tree: Permissions
  permissions(where: QueryPermissionsWhereWhereConditions): [PermissionCategory]

  # Получить список Цен
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по имени, тип, тип операции, период
  priceListFees(
    hasList: QueryPriceListFeesHasListWhereHasConditions
    price_list_id: ID
    where: QueryPriceListFeesWhereWhereConditions
  ): [PriceListFee!]!

  # Получить реквизиты по ID
  requisite(id: ID): Requisites

  # Получить роль по ID
  role(id: ID): Role

  # Получить по билет ID
  ticketComment(id: ID): TicketComments

  # Получить список
  getTicketComments: [TicketComments!]!

  # Получить по билет ID
  ticket(id: ID): Ticket

  # Получить второй фактор по ID
  twoFactorAuth(id: ID): TwoFactorAuthSettings

  # Получить список языков
  languages(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): LanguagesPaginator

  # Получить список лимитов
  accountLimits(
    hasCurrency: QueryAccountLimitsHasCurrencyWhereHasConditions
    hasAccount: QueryAccountLimitsHasAccountWhereHasConditions
    hasCommissionTemplateLimitType: QueryAccountLimitsHasCommissionTemplateLimitTypeWhereHasConditions
    hasCommissionTemplateLimitTransferDirection: QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionWhereHasConditions
    hasCommissionTemplateLimitPeriod: QueryAccountLimitsHasCommissionTemplateLimitPeriodWhereHasConditions
    hasCommissionTemplateLimitActionType: QueryAccountLimitsHasCommissionTemplateLimitActionTypeWhereHasConditions
    where: QueryAccountLimitsWhereWhereConditions
    orderBy: [QueryAccountLimitsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): AccountLimitPaginator

  # Получить список лимитов
  accountReachedLimits(
    hasAccount: QueryAccountReachedLimitsHasAccountWhereHasConditions
    where: QueryAccountReachedLimitsWhereWhereConditions
    orderBy: [QueryAccountReachedLimitsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): AccountReachedLimitPaginator

  # Получить список аккаунтов
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  accounts(
    hasClientable: QueryAccountsHasClientableWhereHasConditions
    query: QueryAccountCondition
    created_at: DateRange
    orderBy: [QueryAccountsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): AccountsPaginator

  # Получить список частных пользователей
  # orderBy: [{ column: FIRST_NAME, order: DESC }] сортировка по ID, по имени, фамилии, email
  # where:{column: EMAIL, operator: LIKE, value: ""} фильтр по имени, фамилии, Email
  applicantIndividuals(
    hasRiskLevel: QueryApplicantIndividualsHasRiskLevelWhereHasConditions
    hasStateReason: QueryApplicantIndividualsHasStateReasonWhereHasConditions
    hasStatus: QueryApplicantIndividualsHasStatusWhereHasConditions
    hasGroupRole: QueryApplicantIndividualsHasGroupRoleWhereHasConditions
    created_at: DateRange
    group: Sort
    company: Sort
    where: QueryApplicantIndividualsWhereWhereConditions
    orderBy: [QueryApplicantIndividualsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualPaginator

  # Получить список пользователей
  # orderBy: [{ column: APPLICANT_INDIVIDUAL_ID, order: DESC }] сортировка по ID, по имени, фамилии, email
  # where:{column: APPLICANT_INDIVIDUAL_ID, value: ""} фильтр по applicant_individual_id
  applicantBankingAccess(
    where: QueryApplicantBankingAccessWhereWhereConditions
    orderBy: [QueryApplicantBankingAccessOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantBankingAccessPaginator

  # Получить список applicant companies
  # orderBy: [{ column: FIRST_NAME, order: DESC }] сортировка по ID, по имени, фамилии, email
  # where:{column: EMAIL, operator: LIKE, value: ""} фильтр по имени, фамилии, Email
  applicantCompanies(
    hasGroupRole: QueryApplicantCompaniesHasGroupRoleWhereHasConditions
    hasRiskLevel: QueryApplicantCompaniesHasRiskLevelWhereHasConditions
    hasStateReason: QueryApplicantCompaniesHasStateReasonWhereHasConditions
    hasStatus: QueryApplicantCompaniesHasStatusWhereHasConditions
    hasBusinessType: QueryApplicantCompaniesHasBusinessTypeWhereHasConditions
    hasOwner: QueryApplicantCompaniesHasOwnerWhereHasConditions
    hasKycLevel: QueryApplicantCompaniesHasKycLevelWhereHasConditions
    created_at: DateRange
    group: Sort
    company: Sort
    where: QueryApplicantCompaniesWhereWhereConditions
    orderBy: [QueryApplicantCompaniesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyPaginator

  # Получить список applicant individuals по applicant company
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: applicant_company_id, operator: LIKE, value: ""} фильтр по applicant_company_id
  getMatchedUsers(
    applicant_company_id: ID!
    orderBy: [QueryGetMatchedUsersOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualCompanyPaginator

  # Получить все типы бизнеса
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantCompanyBusinessType(
    where: QueryApplicantCompanyBusinessTypeWhereWhereConditions
    orderBy: [QueryApplicantCompanyBusinessTypeOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyBusinessTypePaginator
  applicantCompanyLabelsAvailable(
    company_id: ID
    orderBy: [QueryApplicantCompanyLabelsAvailableOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyLabelPaginator

  # Получить список всех модулей компании
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  applicantCompanyModules(
    where: QueryApplicantCompanyModulesWhereWhereConditions
    orderBy: [QueryApplicantCompanyModulesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyModulesPaginator

  # Получить список всех заметок
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по ID, по времени создания
  applicantCompanyNotes(
    orderBy: [QueryApplicantCompanyNotesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyNotesPaginator

  # Получить список всех уровней рисков
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по ID, по времени создания
  applicantCompanyRiskLevels(
    orderBy: [QueryApplicantCompanyRiskLevelsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyRiskLevelPaginator

  # Получить историю списка уровней риска по аппликанту
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: applicant_id, operator: LIKE, value: ""} фильтр по аппликанту
  applicantCompanyRiskLevelHistory(
    applicant_company_id: ID!
    where: QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions
    orderBy: [QueryApplicantCompanyRiskLevelHistoryOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyRiskLevelHistoryPaginator

  # Получить все  должности
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantIndividualCompanyPositions(
    where: QueryApplicantIndividualCompanyPositionsWhereWhereConditions
    orderBy: [QueryApplicantIndividualCompanyPositionsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualCompanyPositionPaginator

  # Получить все  отношения
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantIndividualCompanyRelations(
    where: QueryApplicantIndividualCompanyRelationsWhereWhereConditions
    orderBy: [QueryApplicantIndividualCompanyRelationsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualCompanyRelationPaginator

  # Получить список всех модулей аппликанта
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  applicantIndividualModules(
    where: QueryApplicantIndividualModulesWhereWhereConditions
    orderBy: [QueryApplicantIndividualModulesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualModulesPaginator

  # Получить список всех уровней рисков
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по ID, по времени создания
  applicantIndividualRiskLevels(
    orderBy: [QueryApplicantIndividualRiskLevelsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualRiskLevelPaginator

  # Получить историю списка уровней риска по аппликанту
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: applicant_id, operator: LIKE, value: ""} фильтр по аппликанту
  applicantRiskLevelHistory(
    applicant_id: ID!
    where: QueryApplicantRiskLevelHistoryWhereWhereConditions
    orderBy: [QueryApplicantRiskLevelHistoryOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantRiskLevelHistoryPaginator

  # Получить список уровней KYC
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantKycLevels(
    where: QueryApplicantKycLevelsWhereWhereConditions
    orderBy: [QueryApplicantKycLevelsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantKycLevelPaginator
  applicantIndividualLabelsAvailable(
    applicant_id: ID
    orderBy: [QueryApplicantIndividualLabelsAvailableOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualLabelPaginator

  # Получить список модулей
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  applicant_modules(
    where: QueryApplicantModulesWhereWhereConditions
    orderBy: [QueryApplicantModulesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantModulesPaginator

  # Получить список всех заметок
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по ID, по времени создания
  applicantIndividualNotes(
    orderBy: [QueryApplicantIndividualNotesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualNotesPaginator

  # Получить список уровней риска
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantRiskLevels(
    where: QueryApplicantRiskLevelsWhereWhereConditions
    orderBy: [QueryApplicantRiskLevelsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantRiskLevelPaginator

  # Получить все состояния
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantStates(
    where: QueryApplicantStatesWhereWhereConditions
    orderBy: [QueryApplicantStatesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantStatePaginator

  # Получить все причины
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantStateReasons(
    where: QueryApplicantStateReasonsWhereWhereConditions
    orderBy: [QueryApplicantStateReasonsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantStateReasonPaginator

  # Получить все статусы
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantStatuses(
    where: QueryApplicantStatusesWhereWhereConditions
    orderBy: [QueryApplicantStatusesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantStatusPaginator

  # Получить список всех бизнесов
  businessActivities(
    where: QueryBusinessActivitiesWhereWhereConditions
    orderBy: [QueryBusinessActivitiesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): BusinessActivityPaginator

  # Получить список прайсов
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  commissionPriceLists(
    hasPaymentSystem: QueryCommissionPriceListsHasPaymentSystemWhereHasConditions
    hasCommissionTemplate: QueryCommissionPriceListsHasCommissionTemplateWhereHasConditions
    hasOwner: QueryCommissionPriceListsHasOwnerWhereHasConditions
    hasCompany: QueryCommissionPriceListsHasCompanyWhereHasConditions
    hasAccount: QueryCommissionPriceListsHasAccountWhereHasConditions
    hasPaymentProvider: QueryCommissionPriceListsHasPaymentProviderWhereHasConditions
    paymentProviderName: Sort
    where: QueryCommissionPriceListsWhereWhereConditions
    orderBy: [QueryCommissionPriceListsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionPriceListPaginator

  # Получить список шаблонов
  # orderBy: [{ column: ID, order: DESC }] сортировка ID, NAME, IS_ACTIVE
  # where:{column: NAME, operator: EQ, value: ""} фильтр по name
  # hasPaymentProvider: {column:NAME,operator:GTE,value:PaymentProviderName} фильтр по провайдеру системам
  # hasBusinessActivity: {column:NAME,operator:GTE,value:BusinessActivityName} фильтр по бизнесу
  # hasOwner: {column:NAME,operator:GTE,value:MemberName} фильтр по владельцу
  # hasAccount: {column:NAME,operator:GTE,value:AccountName} фильтр по имени аккаунта
  # hasCompany: {column:NAME,operator:GTE,value:CompanyName} фильтр по имени компании
  commissionTemplates(
    hasPaymentProvider: QueryCommissionTemplatesHasPaymentProviderWhereHasConditions
    hasBusinessActivity: QueryCommissionTemplatesHasBusinessActivityWhereHasConditions
    hasOwner: QueryCommissionTemplatesHasOwnerWhereHasConditions
    hasAccount: QueryCommissionTemplatesHasAccountWhereHasConditions
    hasCompany: QueryCommissionTemplatesHasCompanyWhereHasConditions
    paymentProviderName: Sort
    where: QueryCommissionTemplatesWhereWhereConditions
    orderBy: [QueryCommissionTemplatesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplatePaginator

  # Получить список лимитов
  commissionTemplateLimits(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitPaginator

  # Получить список типов лимитов
  commissionTemplateLimitActionType(
    where: QueryCommissionTemplateLimitActionTypeWhereWhereConditions
    orderBy: [QueryCommissionTemplateLimitActionTypeOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitActionTypePaginator

  # Получить список типов лимитов
  commissionTemplateLimitPeriods(
    where: QueryCommissionTemplateLimitPeriodsWhereWhereConditions
    orderBy: [QueryCommissionTemplateLimitPeriodsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitPeriodPaginator

  # Получить список направлений
  commissionTemplateLimitTransferDirections(
    where: QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions
    orderBy: [QueryCommissionTemplateLimitTransferDirectionsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitTransferDirectionPaginator

  # Получить список типов лимитов
  commissionTemplateLimitTypes(
    where: QueryCommissionTemplateLimitTypesWhereWhereConditions
    orderBy: [QueryCommissionTemplateLimitTypesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitTypePaginator

  # Получить список компаний
  # member_count: сортировка по количеству участников компании
  # county: сортировка по  стране
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по дате создания, по ID, по названию, email, url
  # created_at: {from:"2021-10-11", to: "2021-10-12"} фильтр по дате
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию, по email , url
  companies(
    created_at: DateRange
    country: Sort
    member_count: Sort
    where: QueryCompaniesWhereWhereConditions
    orderBy: [QueryCompaniesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 100

    # The offset from which items are returned.
    page: Int
  ): CompaniesPaginator

  # Получить список стран
  countries(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CountryPaginator

  # Получить список валют
  currencies(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CurrenciesPaginator

  # Получить список департаментов
  # orderBy: [{ column: ID, order: DESC }] сортировка по названию или по ID
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  # hasCompany: {column:ID,operator:EQ,value:1} фильтр по id компании
  departments(
    hasCompany: QueryDepartmentsHasCompanyWhereHasConditions
    where: QueryDepartmentsWhereWhereConditions
    orderBy: [QueryDepartmentsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): DepartmentsPaginator

  # Получить список должностей
  # orderBy: [{ column: ID, order: DESC }] сортировка по названию, по ID, по is_active
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию, по полю is_active
  # hasDepartment: {column:ID,operator:EQ,value:1} фильтр по id департамента
  departmentPositions(
    hasDepartment: QueryDepartmentPositionsHasDepartmentWhereHasConditions
    where: QueryDepartmentPositionsWhereWhereConditions
    orderBy: [QueryDepartmentPositionsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): DepartmentPositionPaginator

  # Получить список email notification
  # orderBy: [
  # {column: ID, order: DESC},
  # ] сортировка по ID
  # where:{column: TYPE, operator: EQ, value: ""} фильтр по типу нотификаций
  emailNotifications(
    hasApplicantIndividual: QueryEmailNotificationsHasApplicantIndividualWhereHasConditions
    hasApplicantCompany: QueryEmailNotificationsHasApplicantCompanyWhereHasConditions
    hasGroupRole: QueryEmailNotificationsHasGroupRoleWhereHasConditions
    hasMember: QueryEmailNotificationsHasMemberWhereHasConditions
    hasGroupType: QueryEmailNotificationsHasGroupTypeWhereHasConditions
    hasTemplates: QueryEmailNotificationsHasTemplatesWhereHasConditions
    created_at: DateRange
    where: QueryEmailNotificationsWhereWhereConditions
    orderBy: [QueryEmailNotificationsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): EmailNotificationPaginator

  # Получить список билетов
  # orderBy: [
  # {column: ID, order: DESC},
  # ] сортировка по ID
  # where:{column: SUBJECT, operator: LIKE, value: ""} фильтр по имени
  emailTemplates(
    hasCompany: QueryEmailTemplatesHasCompanyWhereHasConditions
    created_at: DateRange
    where: QueryEmailTemplatesWhereWhereConditions
    orderBy: [QueryEmailTemplatesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): EmailTemplatePaginator

  # Получить список файлов
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  files(
    where: QueryFilesWhereWhereConditions
    orderBy: [QueryFilesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): FilesPaginator

  # Получить список групп с ролями
  # orderBy: [{ column: IS_ACTIVE, order: DESC }] сортировка по ID, статусу, описанию
  # where:{column: ID, operator: EQ, value: ""} фильтр по ID, ID группы, ID роли, ID платежного провайдера, ID шаблона комиссий, по статусу
  groups(
    hasPaymentProvider: QueryGroupsHasPaymentProviderWhereHasConditions
    hasCommissionTemplate: QueryGroupsHasCommissionTemplateWhereHasConditions
    hasGroupType: QueryGroupsHasGroupTypeWhereHasConditions
    hasRole: QueryGroupsHasRoleWhereHasConditions
    where: QueryGroupsWhereWhereConditions
    orderBy: [QueryGroupsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): GroupRolePaginator @deprecated
  groupList(
    query: QueryGroupCondition
    orderBy: [QueryGroupListOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): GroupRolePaginator

  # Получить список участников
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: FIRST_NAME, operator: LIKE, value: ""} фильтр по фамилии, имени, email, компании, роли, департаменту, должности
  # hasPosition: {column: GROUP_ROLE_ID, operator:EQ, value: 8} поиск по id GROUP ROLE
  memberAccessLimitations(
    hasGroupRole: QueryMemberAccessLimitationsHasGroupRoleWhereHasConditions
    hasGroup: QueryMemberAccessLimitationsHasGroupWhereHasConditions
    hasProvider: QueryMemberAccessLimitationsHasProviderWhereHasConditions
    hasCommissionTemplate: QueryMemberAccessLimitationsHasCommissionTemplateWhereHasConditions
    where: QueryMemberAccessLimitationsWhereWhereConditions
    orderBy: [QueryMemberAccessLimitationsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): MemberAccessLimitationPaginator

  # Получить список участников
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: FIRST_NAME, operator: LIKE, value: ""} фильтр по фамилии, имени, email, компании, роли, департаменту, должности
  # hasPosition: {column: DEPARTMENT_ID, operator:EQ, value: 8} поиск по id департамента
  members(
    hasDepartment: QueryMembersHasDepartmentWhereHasConditions
    hasGroupRole: QueryMembersHasGroupRoleWhereHasConditions
    where: QueryMembersWhereWhereConditions
    companyName: Sort
    orderBy: [QueryMembersOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): MembersPaginator

  # Получить список провайдеров
  # paymentProviderCountry: country_id - получить все провайдеры по стране
  # paymentProviderCurrency: currency_id - получить все провайдеры по валюте
  # orderBy: [{ column: ID, order: DESC }] сортировка ID, NAME, IS_ACTIVE
  # where:{column: NAME, operator: EQ, value: ""} фильтр по name
  # hasPaymentSystems: {column:NAME,operator:GTE,value:PaymentSystemName} фильтр по платежным системам
  paymentProviders(
    hasPaymentSystems: QueryPaymentProvidersHasPaymentSystemsWhereHasConditions
    where: QueryPaymentProvidersWhereWhereConditions
    orderBy: [QueryPaymentProvidersOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): PaymentProviderPaginator

  # Получить список платежных систем
  paymentSystems(
    hasCountries: QueryPaymentSystemsHasCountriesWhereHasConditions
    hasCurrencies: QueryPaymentSystemsHasCurrenciesWhereHasConditions
    hasProviders: QueryPaymentSystemsHasProvidersWhereHasConditions
    where: QueryPaymentSystemsWhereWhereConditions
    orderBy: [QueryPaymentSystemsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): PaymentSystemPaginator

  # Получить список платежей
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # Фильтры по
  # hasCompany: {column:NAME,operator:GTE,value:CompanyName} фильтр по имени компании
  # hasAccounts: {column:ACCOUNT_ID,operator:GTE,value:AccountNumber} фильтр по account number
  # hasOwner: {column:NAME,operator:GTE,value:MemberName} фильтр по владельцу
  payments(
    hasCompanies: QueryPaymentsHasCompaniesWhereHasConditions
    hasPaymentProvider: QueryPaymentsHasPaymentProviderWhereHasConditions
    hasAccounts: QueryPaymentsHasAccountsWhereHasConditions
    hasOwner: QueryPaymentsHasOwnerWhereHasConditions
    hasPaymentOperation: QueryPaymentsHasPaymentOperationWhereHasConditions
    hasPaymentUrgency: QueryPaymentsHasPaymentUrgencyWhereHasConditions
    hasPaymentStatus: QueryPaymentsHasPaymentStatusWhereHasConditions
    AccountNumber: Sort
    created_at: DateRange
    where: QueryPaymentsWhereWhereConditions
    orderBy: [QueryPaymentsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): PaymentsPaginator

  # Получить список реквизитов
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  requisites(
    where: QueryRequisitesWhereWhereConditions
    orderBy: [QueryRequisitesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): RequisitesPaginator

  # Получить список ролей
  # groups_sort: сортировка по количеству групп
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID или по названию
  # where: {column: name, operator: LIKE, value: "Name"}
  roles(
    groups_sort: Sort
    hasGroupTypes: QueryRolesHasGroupTypesWhereHasConditions
    hasGroups: QueryRolesHasGroupsWhereHasConditions
    where: QueryRolesWhereWhereConditions
    orderBy: [QueryRolesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): RolePaginator

  # Получить список билетов
  # orderBy: [
  # {column: ID, order: DESC},
  # {relation: "company", column: "name"},
  # {relation: "department", column: "name"}
  # ] сортировка по ID, компании, позиционный отдел
  # hasCompany: {column: COMPANY_ID, operator:EQ, value: 1} поиск по id компании
  # hasDepartment: {column: DEPARTMENT_ID, operator:EQ, value: 1} поиск по id Департамента
  # hasPosition: {column: DEPARTMENT_POSITION_ID, operator:EQ, value: 1} поиск по id позици
  # hasMember: {column: MEMBER_ID, operator:EQ, value: 1} поиск по id мембера
  # hasClient: {column: CLIENT_ID, operator:EQ, value: 1} поиск по id Клиента
  # where:{column: TITLE, operator: LIKE, value: ""} фильтр по имени, статуса
  tickets(
    hasCompany: QueryTicketsHasCompanyWhereHasConditions
    hasDepartment: QueryTicketsHasDepartmentWhereHasConditions
    hasPosition: QueryTicketsHasPositionWhereHasConditions
    hasMember: QueryTicketsHasMemberWhereHasConditions
    hasClient: QueryTicketsHasClientWhereHasConditions
    created_at: DateRange
    where: QueryTicketsWhereWhereConditions
    orderBy: [QueryTicketsOrderByRelationOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): TicketPaginator

  # Получить список
  twoFactorsAuth(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): TwoFactorAuthSettingsPaginator

  # Получить список пользователей системы
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: FIRST_NAME, operator: LIKE, value: ""} фильтр по фамилии, имени, email, компании, роли, департаменту, должности
  users(
    where: QueryUsersWhereWhereConditions
    orderBy: [QueryUsersOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): UsersPaginator
}

# Языки
type Languages {
  id: ID!

  # Язык
  name: String!

  # ISO код языка
  iso: String!
}

# Аккаунты
# Banking -> Accounts -> Account Limit
type AccountLimit {
  id: ID!

  # ID account
  account_id: ID

  # ID направления платежа
  commission_template_limit_transfer_direction_id: ID

  # Сумма лимита
  amount: Float

  # ID валюты лимита
  currency_id: ID

  # Валюта
  currency: Currencies

  # ID периода лимита
  commission_template_limit_period_id: ID

  # ID события лимита
  commission_template_limit_action_type_id: ID

  # количество срабатываний лимита
  period_count: Int

  # Получить типы лимита
  commission_template_limit_type: CommissionTemplateLimitType

  # Получить направления лимита
  commission_template_limit_transfer_direction: CommissionTemplateLimitTransferDirection

  # Получить периоды лимита
  commission_template_limit_period: CommissionTemplateLimitPeriod

  # Получить события лимита
  commission_template_limit_action_type: CommissionTemplateLimitActionType

  # Получить Account
  account: Accounts
}

# Валюты
type Currencies {
  id: ID!

  # Название валюты
  name: String!

  # ISO код валюты
  code: String!

  # Количество знаков после запятой
  minor_unit: Int
}

# Типы лимитов шаблонов
# Banking -> Commission Templates -> Template Settings
type CommissionTemplateLimitType {
  id: ID!

  # Название
  name: String!
}

# Направления переводов лимитов шаблонов комиссий
# Banking -> Commission Templates -> Template Settings
type CommissionTemplateLimitTransferDirection {
  id: ID!

  # Название
  name: String!
}

# Периоды шаблонов комиссий
# Banking -> Commission Templates -> Template Settings
type CommissionTemplateLimitPeriod {
  id: ID!

  # Название
  name: String!
}

# Типы событий шаблонов комиссий
# Banking -> Commission Templates -> Template Settings
type CommissionTemplateLimitActionType {
  id: ID!

  # Название
  name: String!
}

# Аккаунты
# Banking -> Accounts -> Accounts List
type Accounts {
  id: ID!

  # Получить связанный код валюты
  currency: Currencies

  # Получить связанного владельца
  owner: ApplicantIndividual

  # Номер аккаунта
  account_number: String!

  # Тип аккаунта
  account_type: AccountType

  # Получить связанного платежного провайдера
  payment_provider_id: PaymentProvider

  # Получить связанного Пеймент систем
  payment_system: PaymentSystem

  # Получить связанный шаблон комиссии
  commission_template_id: CommissionTemplate

  # Получить групроле
  group_role: GroupRole

  # Получить тип группы
  group: GroupType

  # Получить или индивидуала или компании
  client: Client

  # Состояние аккаунта
  account_state: AccountState

  # Компания которой принадлежит аккаунт
  company: Companies

  # Получить менеджера
  member: Members

  # Имя аккаунта
  account_name: String!

  # Основной или нет
  is_primary: Boolean

  # Текущий баланс
  current_balance: Int!

  # Текущий баланс
  reserved_balance: Int!

  # Текущий баланс
  available_balance: Int!
  created_at: DateTime
  updated_at: DateTime
  activated_at: DateTime
}

# Частный пользователь
# Management -> New Applicant -> Create Individual -> General
type ApplicantIndividual {
  id: ID!

  # Имя
  first_name: String

  # Фамилия
  last_name: String

  # Отчество
  middle_name: String

  # email
  email: EMAIL

  # Адрес сайта
  url: String

  # Телефон
  phone: String

  # Верецифиорован телефон true/false
  is_verification_phone: Boolean

  # Получить связанную страну
  country: Country

  # Получить язык
  language: Languages

  # Получить связанную страну гражданства
  citizenship_country: Country

  # Штат / область
  state: String

  # Город
  city: String

  # Адрес
  address: String

  # Индекс
  zip: String

  # Национальность
  nationality: String

  # Получить связанную страну рождения
  birth_country: Country

  # Штат/область рождения
  birth_state: String

  # Город рождения
  birth_city: String

  # Дата рождения
  birth_at: Date

  # Пол
  sex: Sex

  # Время создания
  created_at: DateTime

  # Дополнительные поля Profile data
  profile_additional_fields: JSON

  # Дополнительные поля для Personal info
  personal_additional_fields: JSON

  # Дополнительные поля блока контакты
  contacts_additional_fields: JSON

  # Полное имя
  fullname: String

  # Получить статусы
  status: ApplicantStatus

  # Получить состояния
  applicant_state: ApplicantState

  # Получить причины
  state_reason: ApplicantStateReason

  # Получить уровни рисков
  risk_level: ApplicantRiskLevel

  # Получить менеджера
  manager: Members

  # Получить метки
  labels: [ApplicantIndividualLabel]

  # Название компании держателя applicant
  created_for: Companies

  # Получить заметки
  notes: [ApplicantIndividualNotes]

  # Получить модули
  modules: [ApplicantIndividualModules]

  # Получить компании
  companies: [ApplicantCompany]

  # Получить группу
  group: GroupRole

  # Получить two factor auth
  two_factor_auth: TwoFactorAuthSettings
}

# A [RFC 5321](https://tools.ietf.org/html/rfc5321) compliant email.
scalar EMAIL

# Страна
type Country {
  id: ID!

  # Название страны
  name: String!

  # 3х значный ISO код
  iso: String!
}

scalar Date

enum Sex {
  Male
  Female
}

scalar DateTime

# Arbitrary data encoded in JavaScript Object Notation. See https://www.json.org/.
scalar JSON

# Статусы
# Management -> New Applicant -> Create Individual -> General
type ApplicantStatus {
  id: ID!

  # Название
  name: String!
}

# Состояния
# Management -> New Applicant -> Create Individual -> General
type ApplicantState {
  id: ID!

  # Название
  name: String!
}

# State reason
# Management -> New Applicant -> Create Individual -> General
type ApplicantStateReason {
  id: ID!

  # Название
  name: String!
}

# Уровни риска
# Management -> New Applicant -> Create Individual -> General
type ApplicantRiskLevel {
  id: ID!

  # Название
  name: String!
}

# Участники
# Administration->Members
type Members {
  id: ID!

  # Имя участника
  first_name: String

  # Фамилия участника
  last_name: String

  # Email участника
  email: EMAIL

  # Пол участника
  sex: Sex

  # Активен = true или не активный = false участник
  is_active: Boolean

  # Последняя авторизация
  last_login_at: DateTime

  # ID компании
  company_id: ID

  # получить компанию участника
  company: Companies!

  # получить страну участника
  country: Country

  # Получить язык участника
  language: Languages

  # Получить группу участника
  group: GroupRole

  # Получить должность
  position: DepartmentPosition

  # Получить департамент
  department: Departments

  # ID настройки двухфактороной авторизации
  two_factor_auth_setting_id: ID

  # Получить настройки двухфакторной авторизации
  two_factor_auth_settings: TwoFactorAuthSettings

  # Дополнительны поля
  additional_fields: JSON

  # Дополнительны поля для member info
  additional_info_fields: JSON

  # Полное имя
  fullname: String

  # Access limitation groups
  access_groups: [MemberAccessLimitation]

  # если true видит только своих аппликантов
  is_show_owner_applicants: Boolean

  # Security PIN
  security_pin: String

  # Member Backup Codes
  backup_codes: JSON

  # Подписывать или нет транзакцию
  is_sign_transaction: Boolean

  # Member ip address
  ip_addresses: [ClientIpAddress]
}

# Компания
# Administration->Company Info
# error codes: 500, 400
type Companies {
  id: ID!

  # Название компании
  name: String!

  # URL компании
  url: String

  # E-mail компании
  email: EMAIL!

  # Регистрационный номер компании
  company_number: String

  # Контактное лицо
  contact_name: String

  # Страна
  country: Country

  # Индекс
  zip: String

  # Город
  city: String

  # Адресс
  address: String

  # Участники компании
  members: [Members]

  # Количество участников в компании
  members_count: Int

  # Департаменты компании
  departments: [Departments]

  # Должности компании
  positions: [DepartmentPosition]

  # Получить настройки компании
  company_settings: CompanySettings

  # Дополнительные поля
  additional_fields: JSON
  created_at: DateTime!
  updated_at: DateTime!
}

# Департаменты
# Administration->Company Info->Full Profile->Departments
type Departments {
  id: ID!

  # Название департамента
  name: String!

  # Получить компанию
  company: Companies

  # Получить должность
  positions: [DepartmentPosition]
}

# Должности
type DepartmentPosition {
  id: ID!

  # Назварие должности
  name: String!

  # Активен = true или не активный = false
  is_active: Boolean

  # Получить компанию
  company: Companies

  # Получить департамент
  department: Departments
}

# Настройки компании
# Administration->Company Info->Full Profile->Branding
type CompanySettings {
  company_id: ID

  # URL в тексте письма
  email_url: String

  # Email для jwt
  email_jwt: String

  # Email отправителя
  email_from: EMAIL

  # ID файла логотипа из хранилища
  logo_object_key: String

  # Данные о компании
  company: Companies

  # Показывать или нет лого
  show_own_logo: Boolean
}

type GroupRole {
  id: ID!

  # Название группы
  name: String

  # ID типа группы
  group_type_id: ID

  # ID роли
  role_id: ID

  # Описание группы
  description: String

  # Активная и не активная группа
  is_active: Boolean

  # Получить тип группы
  group_type: GroupType

  # Получить связанную роль
  role: Role

  # Получить связанный платежный провайдер
  payment_provider: PaymentProvider

  # Получит свящанный шаблон комиссий
  commission_template: CommissionTemplate
  company: Companies
}

# Группы
type GroupType {
  id: ID!

  # Название группы
  name: GroupsEntities!
}

# Список групп
# Settings->Manager Groups->Groups List
enum GroupsEntities {
  Member
  Company
  Individual
}

# Роли
# Settings->Manager Roles->Roles List
type Role {
  id: ID!

  # Название роли
  name: String!

  # Описание для роли
  description: String

  # Получить список полномочий
  permissions: [Permissions]

  # Получить список категорий полномочий
  permission_category_all_member: [PermissionCategory]

  # Получить дерево разрешений
  permissions_tree: JSON

  # Получить тип группы
  group_type: GroupType

  # Получить компанию
  company: Companies

  # Получить список групп
  groups: [GroupRole]

  # Получить количество групп с данной ролью
  groups_count: Int
  is_all_companies: Boolean
}

# Список разрешений
# Settings->Manager Roles->Rol
type Permissions {
  id: ID
  name: String
  display_name: String
  guard_name: String
  type: String
  all: JSON
}

type PermissionCategory {
  id: ID
  name: String
  permissionList(
    permissionType: PermissionCategoryPermissionListPermissionTypeWhereConditions
  ): [PermissionList]
}

# Dynamic WHERE conditions for the `permissionType` argument on the query `permissionList`.
input PermissionCategoryPermissionListPermissionTypeWhereConditions {
  # The column that is used for the condition.
  column: PermissionCategoryPermissionListPermissionTypeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [PermissionCategoryPermissionListPermissionTypeWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [PermissionCategoryPermissionListPermissionTypeWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: PermissionCategoryPermissionListPermissionTypeWhereConditionsRelation
}

# Allowed column names for PermissionCategory.permissionList.permissionType.
enum PermissionCategoryPermissionListPermissionTypeColumn {
  TYPE
}

# The available SQL operators that are used to filter query results.
enum SQLOperator {
  # Equal operator (`=`)
  EQ

  # Not equal operator (`!=`)
  NEQ

  # Greater than operator (`>`)
  GT

  # Greater than or equal operator (`>=`)
  GTE

  # Less than operator (`<`)
  LT

  # Less than or equal operator (`<=`)
  LTE

  # Simple pattern matching (`LIKE`)
  LIKE

  # Negation of simple pattern matching (`NOT LIKE`)
  NOT_LIKE

  # Whether a value is within a set of values (`IN`)
  IN

  # Whether a value is not within a set of values (`NOT IN`)
  NOT_IN

  # Whether a value is within a range of values (`BETWEEN`)
  BETWEEN

  # Whether a value is not within a range of values (`NOT BETWEEN`)
  NOT_BETWEEN

  # Whether a value is null (`IS NULL`)
  IS_NULL

  # Whether a value is not null (`IS NOT NULL`)
  IS_NOT_NULL
}

# Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
# as they may not be parsed correctly on the server side. Use `String` literals if you are
# dealing with really large numbers to be on the safe side.
scalar Mixed

# Dynamic HAS conditions for WHERE conditions for the `permissionType` argument on the query `permissionList`.
input PermissionCategoryPermissionListPermissionTypeWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: PermissionCategoryPermissionListPermissionTypeWhereConditions
}

type PermissionList {
  id: ID
  name: String
  type: PermissionListType
  separator: PermissionSeparatorType
  permissions: [Permissions]
}

enum PermissionListType {
  Member
  Individual
}

enum PermissionSeparatorType {
  Private
  Business
}

# Платежные провайдеры
# Banking -> Payment Providers
type PaymentProvider {
  id: ID!

  # Название провайдера
  name: String!

  # Описание провайдера
  description: String

  # ключ для получения изображения в Object Storage
  logo_key: String

  # Активен или нет
  is_active: Boolean

  # Получить связанные платежные системы
  payment_systems: [PaymentSystem]
  commission_price_list: CommissionPriceList
}

# Платежные системы
# Settings->Payment System
type PaymentSystem {
  id: ID!

  # Название платежной системы
  name: String!

  # Активна или нет
  is_active: Boolean

  # Получить связанные страны
  countries: [Country]

  # Получить связанные валюты
  currencies: [Currencies]

  # Получить Платежные провайдеры
  providers: [PaymentProvider]
}

# Прайс лист комиссий
# Banking -> Commission Price List
type CommissionPriceList {
  id: ID!

  # Название шаблона
  name: String!

  # Получить связанный платежный провайдер
  provider: PaymentProvider

  # Получить связанного мембера
  owner: [ApplicantIndividual]

  # Получить компанию
  company: [ApplicantCompany]

  # Получить связанный аккаунт
  account: Accounts

  # Получить связанную платежную систему
  payment_system: PaymentSystem

  # Получить связанный платежный шаблон
  commission_template: CommissionTemplate

  # Получить связанные цены
  fees: [PriceListFee]
}

# Компания пользователя
# Management -> New Applicant -> Create Company
type ApplicantCompany {
  id: ID!

  # Название
  name: String

  # email
  email: EMAIL

  # Адрес сайта
  url: String

  # Телефон
  phone: String

  # Верецифиорован телефон true/false
  is_verification_phone: Boolean

  # Получить связанную страну
  country: Country

  # Получить язык
  language: Languages

  # Штат / область
  state: String

  # Город
  city: String

  # Адрес
  address: String

  # Адрес2
  address2: String

  # Адрес офиса
  office_address: String

  # Индекс
  zip: String

  # Дата регистрации
  reg_at: Date

  # Дата окончания регистрации
  expires_at: Date

  # Налоговый номер
  tax: String

  # Регистрационный номер
  reg_number: String

  # Номер лицензии
  license_number: String

  # Тип компании
  company_type: String

  # Дополнительные поля Company Info
  company_info_additional_fields: JSON

  # Дополнительные поля блока контакты
  contacts_additional_fields: JSON

  # Дополнительные поля Profile data
  profile_additional_fields: JSON

  # Дата создания
  created_at: DateTime

  # Получить тип бизнеса
  business_type: ApplicantCompanyBusinessType

  # Получить статусы
  status: ApplicantStatus

  # Получить состояния
  applicant_state: ApplicantState

  # Получить причины
  state_reason: ApplicantStateReason

  # Получить уровни рисков
  risk_level: ApplicantRiskLevel

  # Получить KYC level
  kyc_level: ApplicantRiskLevel

  # Получить менеджера
  manager: Members

  # Получить создателя
  owner: ApplicantIndividual

  # Получить метки
  labels: [ApplicantCompanyLabel]

  # Получить заметки
  notes: [ApplicantCompanyNotes]
  modules: [ApplicantCompanyModules]
  company_position: ApplicantIndividualCompany
  owner_relation: ApplicantIndividualCompany
  owner_position: ApplicantIndividualCompany
  company: Companies

  # Получить группу
  group: GroupRole
}

# Типы бизнеса для компании
# Management -> New Applicant -> Create Company
type ApplicantCompanyBusinessType {
  id: ID!

  # Название
  name: String!
}

# Метки компании
# Management -> New Applicant -> Create Company
type ApplicantCompanyLabel {
  id: ID!

  # Название метки
  name: String!

  # HEX код метки
  hex_color_code: String!
  is_active: Boolean
}

# Заметки компания
# Dashboard -> Applicants -> Company
type ApplicantCompanyNotes {
  id: ID!

  # Заметка
  note: String!

  # Дата и время создания
  created_at: DateTime

  # Получить автора
  author: Members

  # Получить пользователя
  applicant: ApplicantCompany
}

# Модули компании
# Dashboard -> Applicants -> Company -> Full Profile -> Settings
type ApplicantCompanyModules {
  # Получить компанию
  applicant_company: ApplicantCompany

  # Получить модуль
  applicant_module: ApplicantModules
  applicant_module_id: ID

  # Активен = true или не активный = false
  is_active: Boolean
}

# Управление модулями
# Dashboard -> Applicants -> Company->Full Profile -> Settings
type ApplicantModules {
  id: ID!

  # Название модуля
  name: String!
}

type ApplicantIndividualCompany {
  applicant_individual_id: ID!
  applicant_company_id: ID!
  applicant_individual_company_relation_id: ID!
  applicant_individual_company_position_id: ID!
  applicant_individual: ApplicantIndividual
  relation_to_company: ApplicantIndividualCompanyRelation
  position_in_company: ApplicantIndividualCompanyPosition
}

# Отношения компании
# Management -> New Applicant -> Create Company
type ApplicantIndividualCompanyRelation {
  id: ID!

  # Название
  name: String!
}

# Должности компании
# Management -> New Applicant -> Create Company
type ApplicantIndividualCompanyPosition {
  id: ID!

  # Название должности
  name: String!
}

# Шаблоны комиссий
# Banking -> Commission Templates -> Template List
type CommissionTemplate {
  id: ID!

  # Название шаблона
  name: String!

  # Описание шаблона
  description: String

  # Активен или нет
  is_active: Boolean

  # массив ID стран
  country_id: [ID]

  # массив ID валют
  currency_id: [ID]

  # Получить связанный платежный провайдер
  payment_provider: PaymentProvider

  # Получить список бизнесов
  business_activity: [BusinessActivity]

  # Получить связанного мембера
  owner: [ApplicantIndividual]

  # Получить связанный аккаунт
  account: Accounts

  # Получить компанию
  company: [ApplicantCompany]
  countries: [Country]
  currencies: [Currencies]
  commission_template_limits: [CommissionTemplateLimit]
}

# Business Activity
# Banking -> Commission Templates -> Template Settings
type BusinessActivity {
  id: ID!

  # Название
  name: String!
}

# Лимиты комиссий
# Banking -> Commission Templates -> Template List
type CommissionTemplateLimit {
  id: ID!

  # ID типа лимита
  commission_template_limit_type_id: ID

  # ID направления платежа
  commission_template_limit_transfer_direction_id: ID

  # Сумма лимита
  amount: Float

  # ID валюты лимита
  currency_id: ID

  # Валюта
  currency: Currencies

  # ID периода лимита
  commission_template_limit_period_id: ID

  # ID события лимита
  commission_template_limit_action_type_id: ID

  # количество срабатываний лимита
  period_count: Int

  # Получить типы лимита
  commission_template_limit_type: CommissionTemplateLimitType

  # Получить направления лимита
  commission_template_limit_transfer_direction: CommissionTemplateLimitTransferDirection

  # Получить периоды лимита
  commission_template_limit_period: CommissionTemplateLimitPeriod

  # Получить события лимита
  commission_template_limit_action_type: CommissionTemplateLimitActionType

  # Получить шаблон комиссии
  commission_template: CommissionTemplate
}

# Цены прайс листа
# Banking -> Цены прайс листа
type PriceListFee {
  id: ID!

  # Название
  name: String!

  # Тип
  fee_type: FeeType

  # Тип операции
  operation_type: OperationType

  # Период
  period: FeePeriod

  # Цены
  fees_item: [PriceListFeesItem]

  # Получить Прайс лист комиссий
  list: CommissionPriceList
  created_at: DateTime
  updated_at: DateTime
}

# Типы платежей
type FeeType {
  id: ID!

  # Название
  name: String!
}

# Типы операций
type OperationType {
  id: ID
  name: String
}

# Периоды комиссий
type FeePeriod {
  id: ID
  name: String
}

type PriceListFeesItem {
  id: ID
  fee_item: JSON
}

# Методы двухфакторной авторизации
type TwoFactorAuthSettings {
  id: ID!

  # Название второго фактора
  name: String!
}

# Участники
# Administration->Members->MemberAccessLimitation
type MemberAccessLimitation {
  id: ID!

  # Получить Group
  member: Members

  # Получить GroupType
  group: GroupType

  # Получить groupRole
  group_role: GroupRole

  # Получить связанный платежный провайдер
  provider: PaymentProvider

  # Получить связанный платежный шаблон
  commission_template: CommissionTemplate
}

# Client ip address
type ClientIpAddress {
  id: ID!

  # ip_address
  ip_address: String

  # Client type
  client_type: String

  # Client ID
  client_id: ID
}

# Метки пользователя
# Management -> New Applicant -> Create Individual -> General
type ApplicantIndividualLabel {
  id: ID!

  # Название метки
  name: String!

  # HEX код метки
  hex_color_code: String!
  is_active: Boolean
}

# Заметки частный пользователь
# Dashboard -> Applicants -> Individual
type ApplicantIndividualNotes {
  id: ID!

  # Заметка
  note: String!

  # Дата и время создания
  created_at: DateTime

  # Получить автора
  author: Members

  # Получить пользователя
  applicant: ApplicantIndividual
}

# Модули аппликанта
# Dashboard -> Applicants -> Individual -> Full Profile -> Settings
type ApplicantIndividualModules {
  # Получить индивидуала
  applicant_individual: ApplicantIndividual

  # Получить модуль
  applicant_module: ApplicantModules
  applicant_module_id: ID

  # Активен = true или не активный = false
  is_active: Boolean
}

enum AccountType {
  Private
  Business
}

union Client = ApplicantIndividual | ApplicantCompany

type AccountState {
  id: ID!
  name: String!
}

# AccountReachedLimit
# Banking -> Accounts -> Account Limit
type AccountReachedLimit {
  id: ID!

  # ID account
  account_id: ID!

  # Получить Account
  account: Accounts

  # Тип
  group_type: String!

  # Имя аппликанта
  client_name: String!

  # Тип аппликанта
  client_type: String!

  # Тип трансфера
  transfer_direction: String!

  # Тип лимита
  limit_type: String!

  # Значение лимита
  limit_value: Int!

  # Валюта лимита
  limit_currency: String!

  # Период
  period: Int!

  # Сумма
  amount: Float!
}

# Order by clause for Query.accountStates.orderBy.
input QueryAccountStatesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryAccountStatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.accountStates.orderBy.
enum QueryAccountStatesOrderByColumn {
  ID
  NAME
}

# Directions for ordering a list of records.
enum SortOrder {
  # Sort records in ascending order.
  ASC

  # Sort records in descending order.
  DESC
}

# Order by clause for Query.owners.orderBy.
input QueryOwnersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryOwnersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.owners.orderBy.
enum QueryOwnersOrderByColumn {
  ID
  EMAIL
  CREATED_AT
  FULLNAME
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanyLabels`.
input QueryApplicantCompanyLabelsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompanyLabelsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompanyLabelsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompanyLabelsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompanyLabelsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanyLabels.where.
enum QueryApplicantCompanyLabelsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanyLabels`.
input QueryApplicantCompanyLabelsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompanyLabelsWhereWhereConditions
}

# Order by clause for Query.applicantCompanyLabels.orderBy.
input QueryApplicantCompanyLabelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyLabelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyLabels.orderBy.
enum QueryApplicantCompanyLabelsOrderByColumn {
  ID
  NAME
}

# Уровни риска компания
# Dashboard -> Applicants -> Company
type ApplicantCompanyRiskLevel {
  id: ID!

  # Описание
  description: String!

  # Дата и время создания
  created_at: DateTime

  # Получить автора
  author: Members

  # Получить пользователя
  applicant: ApplicantCompany
}

# Уровни риска пользователя
# Dashboard -> Applicants -> Individual
type ApplicantIndividualRiskLevel {
  id: ID!

  # Описание
  description: String!

  # Дата и время создания
  created_at: DateTime

  # Получить автора
  author: Members

  # Получить пользователя
  applicant: ApplicantIndividual
}

# Уровни KYC
# Management -> New Applicant
type ApplicantKycLevel {
  id: ID!

  # Название
  name: String!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantIndividualLabels`.
input QueryApplicantIndividualLabelsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualLabelsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualLabelsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualLabelsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualLabelsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantIndividualLabels.where.
enum QueryApplicantIndividualLabelsWhereColumn {
  NAME
  APPLICANT_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantIndividualLabels`.
input QueryApplicantIndividualLabelsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualLabelsWhereWhereConditions
}

# Order by clause for Query.applicantIndividualLabels.orderBy.
input QueryApplicantIndividualLabelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualLabelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualLabels.orderBy.
enum QueryApplicantIndividualLabelsOrderByColumn {
  APPLICANT_ID
  NAME
}

# Шаблоны электронной почты
# Banking-> Email Notifications
type EmailNotification {
  id: ID!

  # Тип
  type: NotifyType

  # Тип получателя
  recipient_type: RecipientType

  # Тип Группы
  group_type: GroupType

  # Получить templates
  templates: [EmailTemplate]

  # Получить клиента ApplicantIndividual | ApplicantCompany | Members
  clientable: Clientable

  # Получить компанию
  company: Companies

  # Получить Group Role
  group_role: GroupRole
  created_at: DateTime
  updated_at: DateTime
}

enum NotifyType {
  Administration
  Client
}

enum RecipientType {
  PERSON
  GROUP
}

# Шаблоны электронной почты
# Banking-> Email Templates Settings
type EmailTemplate {
  id: ID!

  # Название
  name: String!

  # Тема
  subject: String!

  # Тип
  type: ClientType!

  # Тип сервиса
  service_type: ServiceType!

  # Контент
  content: String!

  # Header
  header: String

  # Footer
  footer: String

  # Получить Компанию
  company: Companies
  created_at: DateTime
  updated_at: DateTime
  use_layout: Boolean
}

enum ClientType {
  Administration
  Client
}

enum ServiceType {
  Banking
  Common
  System
  AdminNotify
}

union Clientable = ApplicantIndividual | ApplicantCompany | Members

# Шаблоны электронной почты
# Banking-> Email Templates Settings
type EmailSmtp {
  id: ID!

  # Защита
  security: Securities

  # Имя хоста
  host_name: String!

  # От кого
  from_name: String

  # почта
  from_email: String

  # логин
  username: String!

  # пароль
  password: String!

  # ответить кому
  replay_to: String

  # Порт
  port: Int!

  # Определяем отправлять через данные настройки всю почту или нет
  is_sending_mail: Boolean

  # Название шаблона
  name: String

  # Получить мембера
  member: Members

  # Получить компанию
  company: Companies
}

enum Securities {
  Auto
  Ssl
  Starttls
}

# Order by clause for Query.emailSmtps.orderBy.
input QueryEmailSmtpsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryEmailSmtpsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.emailSmtps.orderBy.
enum QueryEmailSmtpsOrderByColumn {
  ID
  NAME
}

type EmailTemplateLayout {
  id: ID!

  # Header
  header: String!

  # Footer
  footer: String!

  # Ид компании
  company_id: Int!
  created_at: DateTime
  updated_at: DateTime
}

# Режимы комиссий
type FeesMode {
  id: ID
  name: String
}

# Файлы
type Files {
  id: ID!

  # Исходное имя файла
  file_name: String!

  # Тип файла
  mime_type: String!

  # Размер загружаемого файла
  size: Int!

  # Тип сущности для которой загружается файл
  entity_type: String!

  # Кто загружал файл
  author_id: Int!

  # Путь к загруженному файлу на ovh
  storage_path: String!

  # Название файла на ovh
  storage_name: String!

  # Ссылка на файл
  link: String!
  created_at: DateTime
  updated_at: DateTime
}

enum GroupTypeMode {
  CLIENTS
  ALL
}

# Dynamic WHERE conditions for the `where` argument on the query `operationTypes`.
input QueryOperationTypesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryOperationTypesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryOperationTypesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryOperationTypesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryOperationTypesWhereWhereConditionsRelation
}

# Allowed column names for Query.operationTypes.where.
enum QueryOperationTypesWhereColumn {
  FEE_TYPE_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `operationTypes`.
input QueryOperationTypesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryOperationTypesWhereWhereConditions
}

# Типы платежей
type PaymentStatus {
  id: ID!

  # Название
  name: String!
}

# Типы платежей
type PaymentTypes {
  id: ID!

  # Название
  name: String!
}

# Срочность
type PaymentUrgency {
  id: ID!

  # Название
  name: String!
}

type Sender {
  # Sender name
  sender_name: String!
}

# Платежи
# Banking -> Payments List
type Payments {
  id: ID!

  # Сумма
  amount: Float!
  amount_real: Float!

  # Комиссия
  fee: Float
  fee_type: FeeType

  # Получить связанную валюту
  currency: Currencies

  # Статус
  status: PaymentStatus

  # Имя отправителя
  sender_name: String

  # Детали платежа
  payment_details: String

  # Аккаунт банка отправителя
  sender_bank_account: String

  # SWIFT отправителя
  sender_swift: String

  # Имя банка отправителя
  sender_bank_name: String

  # Страна банка отправителя
  sender_bank_country: Country

  # Адрес банка отправителя
  sender_bank_address: String

  # Страна отправителя
  sender_country_id: Country

  # Адрес отправителя
  sender_address: String

  # Получить связанныую срочность
  payment_urgency: PaymentUrgency

  # Получить связанный тип
  payment_operation_type: OperationType

  # Получить связанный провайдер
  payment_provider: PaymentProvider

  # Получить связанный аккаунт
  account: Accounts

  # Получить связанную компанию
  company: Companies

  # Номер платежа
  payment_number: String
  created_at: DateTime
  updated_at: DateTime

  # Получить связанного мембера
  member: Members

  # Получить владельца
  owner: [ApplicantIndividual]
  received_at: DateTime
  error: String
  sender_additional_fields: JSON
}

# Dynamic WHERE conditions for the `where` argument on the query `permissions`.
input QueryPermissionsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryPermissionsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPermissionsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPermissionsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPermissionsWhereWhereConditionsRelation
}

# Allowed column names for Query.permissions.where.
enum QueryPermissionsWhereColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `permissions`.
input QueryPermissionsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPermissionsWhereWhereConditions
}

# Dynamic WHERE conditions for the `hasList` argument on the query `priceListFees`.
input QueryPriceListFeesHasListWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPriceListFeesHasListColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPriceListFeesHasListWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPriceListFeesHasListWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPriceListFeesHasListWhereHasConditionsRelation
}

# Allowed column names for Query.priceListFees.hasList.
enum QueryPriceListFeesHasListColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasList` argument on the query `priceListFees`.
input QueryPriceListFeesHasListWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPriceListFeesHasListWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `priceListFees`.
input QueryPriceListFeesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryPriceListFeesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPriceListFeesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPriceListFeesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPriceListFeesWhereWhereConditionsRelation
}

# Allowed column names for Query.priceListFees.where.
enum QueryPriceListFeesWhereColumn {
  NAME
  TYPE_ID
  OPERATION_TYPE_ID
  PERIOD_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `priceListFees`.
input QueryPriceListFeesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPriceListFeesWhereWhereConditions
}

# Реквизиты
# Banking -> Accounts -> Requisites
type Requisites {
  id: ID!
  created_at: DateTime
  updated_at: DateTime

  # Получить связанный аккаунт
  account_id: Accounts

  # Получатель
  recipient: String!

  # Registration Number
  registration_number: Int!

  # Адрес
  address: String!

  # Получить связанную страну
  country_id: Country

  # Название банка
  bank_name: String!

  # Адрес банка
  bank_address: String!

  # Получить связанную страну банка
  bank_country_id: Country

  # IBAN
  iban: String!

  # Номер аккаунта
  account_no: String!

  # SWIFT
  swift: String!

  # Банк корреспондент
  bank_correspondent: JSON
}

# Комментарии билетов
type TicketComments {
  id: ID!

  # Сообщение
  message: String!

  # Получить файл
  file_object: Files

  # Получить билет
  ticket: Ticket

  # Получить Клиента
  client: ApplicantIndividual
  created_at: DateTime
  updated_at: DateTime
}

# Билеты
# Banking -> Tickets
type Ticket {
  id: ID!

  # Название
  title: String!

  # Сообщение
  message: String!

  # Статус
  status: Int!

  # Получить файл
  file_object: Files

  # Получить компанию
  company: Companies

  # Получить позицию
  position: DepartmentPosition

  # Получить Департаменты
  department: Departments

  # Получить мембера
  member: Members

  # Получить Клиента
  client: ApplicantIndividual

  # Получить комментарии
  comments: [TicketComments]
  created_at: DateTime
  updated_at: DateTime
}

# A paginated list of Languages items.
type LanguagesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Languages items.
  data: [Languages!]!
}

# Information about pagination using a fully featured paginator.
type PaginatorInfo {
  # Number of items in the current page.
  count: Int!

  # Index of the current page.
  currentPage: Int!

  # Index of the first item in the current page.
  firstItem: Int

  # Are there more pages after this one?
  hasMorePages: Boolean!

  # Index of the last item in the current page.
  lastItem: Int

  # Index of the last available page.
  lastPage: Int!

  # Number of items per page.
  perPage: Int!

  # Number of total available items.
  total: Int!
}

# Dynamic WHERE conditions for the `hasCurrency` argument on the query `accountLimits`.
input QueryAccountLimitsHasCurrencyWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountLimitsHasCurrencyColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountLimitsHasCurrencyWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountLimitsHasCurrencyWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountLimitsHasCurrencyWhereHasConditionsRelation
}

# Allowed column names for Query.accountLimits.hasCurrency.
enum QueryAccountLimitsHasCurrencyColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCurrency` argument on the query `accountLimits`.
input QueryAccountLimitsHasCurrencyWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountLimitsHasCurrencyWhereHasConditions
}

# Dynamic WHERE conditions for the `hasAccount` argument on the query `accountLimits`.
input QueryAccountLimitsHasAccountWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountLimitsHasAccountColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountLimitsHasAccountWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountLimitsHasAccountWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountLimitsHasAccountWhereHasConditionsRelation
}

# Allowed column names for Query.accountLimits.hasAccount.
enum QueryAccountLimitsHasAccountColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasAccount` argument on the query `accountLimits`.
input QueryAccountLimitsHasAccountWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountLimitsHasAccountWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCommissionTemplateLimitType` argument on the query `accountLimits`.
input QueryAccountLimitsHasCommissionTemplateLimitTypeWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountLimitsHasCommissionTemplateLimitTypeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountLimitsHasCommissionTemplateLimitTypeWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountLimitsHasCommissionTemplateLimitTypeWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountLimitsHasCommissionTemplateLimitTypeWhereHasConditionsRelation
}

# Allowed column names for Query.accountLimits.hasCommissionTemplateLimitType.
enum QueryAccountLimitsHasCommissionTemplateLimitTypeColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCommissionTemplateLimitType` argument on the query `accountLimits`.
input QueryAccountLimitsHasCommissionTemplateLimitTypeWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountLimitsHasCommissionTemplateLimitTypeWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCommissionTemplateLimitTransferDirection` argument on the query `accountLimits`.
input QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionWhereHasConditionsRelation
}

# Allowed column names for Query.accountLimits.hasCommissionTemplateLimitTransferDirection.
enum QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCommissionTemplateLimitTransferDirection` argument on the query `accountLimits`.
input QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountLimitsHasCommissionTemplateLimitTransferDirectionWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCommissionTemplateLimitPeriod` argument on the query `accountLimits`.
input QueryAccountLimitsHasCommissionTemplateLimitPeriodWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountLimitsHasCommissionTemplateLimitPeriodColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountLimitsHasCommissionTemplateLimitPeriodWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountLimitsHasCommissionTemplateLimitPeriodWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountLimitsHasCommissionTemplateLimitPeriodWhereHasConditionsRelation
}

# Allowed column names for Query.accountLimits.hasCommissionTemplateLimitPeriod.
enum QueryAccountLimitsHasCommissionTemplateLimitPeriodColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCommissionTemplateLimitPeriod` argument on the query `accountLimits`.
input QueryAccountLimitsHasCommissionTemplateLimitPeriodWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountLimitsHasCommissionTemplateLimitPeriodWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCommissionTemplateLimitActionType` argument on the query `accountLimits`.
input QueryAccountLimitsHasCommissionTemplateLimitActionTypeWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountLimitsHasCommissionTemplateLimitActionTypeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountLimitsHasCommissionTemplateLimitActionTypeWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountLimitsHasCommissionTemplateLimitActionTypeWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountLimitsHasCommissionTemplateLimitActionTypeWhereHasConditionsRelation
}

# Allowed column names for Query.accountLimits.hasCommissionTemplateLimitActionType.
enum QueryAccountLimitsHasCommissionTemplateLimitActionTypeColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCommissionTemplateLimitActionType` argument on the query `accountLimits`.
input QueryAccountLimitsHasCommissionTemplateLimitActionTypeWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountLimitsHasCommissionTemplateLimitActionTypeWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `accountLimits`.
input QueryAccountLimitsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryAccountLimitsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountLimitsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountLimitsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountLimitsWhereWhereConditionsRelation
}

# Allowed column names for Query.accountLimits.where.
enum QueryAccountLimitsWhereColumn {
  PERIOD_COUNT
  ACCOUNT_ID
  AMOUNT
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `accountLimits`.
input QueryAccountLimitsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountLimitsWhereWhereConditions
}

# Order by clause for Query.accountLimits.orderBy.
input QueryAccountLimitsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryAccountLimitsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.accountLimits.orderBy.
enum QueryAccountLimitsOrderByColumn {
  ID
}

# A paginated list of AccountLimit items.
type AccountLimitPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of AccountLimit items.
  data: [AccountLimit!]!
}

# Dynamic WHERE conditions for the `hasAccount` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsHasAccountWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountReachedLimitsHasAccountColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountReachedLimitsHasAccountWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountReachedLimitsHasAccountWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountReachedLimitsHasAccountWhereHasConditionsRelation
}

# Allowed column names for Query.accountReachedLimits.hasAccount.
enum QueryAccountReachedLimitsHasAccountColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasAccount` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsHasAccountWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountReachedLimitsHasAccountWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryAccountReachedLimitsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountReachedLimitsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountReachedLimitsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountReachedLimitsWhereWhereConditionsRelation
}

# Allowed column names for Query.accountReachedLimits.where.
enum QueryAccountReachedLimitsWhereColumn {
  ACCOUNT_ID
  GROUP_TYPE
  CLIENT_NAME
  CLIENT_TYPE
  TRANSFER_DIRECTION
  LIMIT_TYPE
  LIMIT_VALUE
  LIMIT_CURRENCY
  PERIOD
  AMOUNT
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountReachedLimitsWhereWhereConditions
}

# Order by clause for Query.accountReachedLimits.orderBy.
input QueryAccountReachedLimitsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryAccountReachedLimitsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.accountReachedLimits.orderBy.
enum QueryAccountReachedLimitsOrderByColumn {
  ID
}

# A paginated list of AccountReachedLimit items.
type AccountReachedLimitPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of AccountReachedLimit items.
  data: [AccountReachedLimit!]!
}

# Dynamic WHERE conditions for the `hasClientable` argument on the query `accounts`.
input QueryAccountsHasClientableWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountsHasClientableColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountsHasClientableWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountsHasClientableWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountsHasClientableWhereHasConditionsRelation
}

# Allowed column names for Query.accounts.hasClientable.
enum QueryAccountsHasClientableColumn {
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasClientable` argument on the query `accounts`.
input QueryAccountsHasClientableWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountsHasClientableWhereHasConditions
}

input QueryAccountCondition {
  client_id: ID
  company_id: ID
  payment_provider_id: ID
  owner_id: ID
  account_number: String
  currency_id: ID
  group_role_id: ID
  group_type_id: ID
  member_id: ID
  is_primary: Boolean
  commission_template_id: ID
  account_type: String
  account_state_id: ID
  account_name: String
}

input DateRange {
  from: Date!
  to: DateEnd!
}

scalar DateEnd

# Order by clause for Query.accounts.orderBy.
input QueryAccountsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryAccountsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.accounts.orderBy.
enum QueryAccountsOrderByColumn {
  ID
  CLIENT_ID
}

# A paginated list of Accounts items.
type AccountsPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Accounts items.
  data: [Accounts!]!
}

# Dynamic WHERE conditions for the `hasRiskLevel` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsHasRiskLevelWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualsHasRiskLevelColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualsHasRiskLevelWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualsHasRiskLevelWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualsHasRiskLevelWhereHasConditionsRelation
}

# Allowed column names for Query.applicantIndividuals.hasRiskLevel.
enum QueryApplicantIndividualsHasRiskLevelColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasRiskLevel` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsHasRiskLevelWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualsHasRiskLevelWhereHasConditions
}

# Dynamic WHERE conditions for the `hasStateReason` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsHasStateReasonWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualsHasStateReasonColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualsHasStateReasonWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualsHasStateReasonWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualsHasStateReasonWhereHasConditionsRelation
}

# Allowed column names for Query.applicantIndividuals.hasStateReason.
enum QueryApplicantIndividualsHasStateReasonColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasStateReason` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsHasStateReasonWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualsHasStateReasonWhereHasConditions
}

# Dynamic WHERE conditions for the `hasStatus` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsHasStatusWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualsHasStatusColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualsHasStatusWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualsHasStatusWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualsHasStatusWhereHasConditionsRelation
}

# Allowed column names for Query.applicantIndividuals.hasStatus.
enum QueryApplicantIndividualsHasStatusColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasStatus` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsHasStatusWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualsHasStatusWhereHasConditions
}

# Dynamic WHERE conditions for the `hasGroupRole` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsHasGroupRoleWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualsHasGroupRoleColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualsHasGroupRoleWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualsHasGroupRoleWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualsHasGroupRoleWhereHasConditionsRelation
}

# Allowed column names for Query.applicantIndividuals.hasGroupRole.
enum QueryApplicantIndividualsHasGroupRoleColumn {
  GROUP_TYPE_ID
  ROLE_ID
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupRole` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsHasGroupRoleWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualsHasGroupRoleWhereHasConditions
}

enum Sort {
  ASC
  DESC
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantIndividuals.where.
enum QueryApplicantIndividualsWhereColumn {
  ID
  FIRST_NAME
  LAST_NAME
  EMAIL
  CREATED_AT
  FULLNAME
  GROUP_ID
  COMPANY_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualsWhereWhereConditions
}

# Order by clause for Query.applicantIndividuals.orderBy.
input QueryApplicantIndividualsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividuals.orderBy.
enum QueryApplicantIndividualsOrderByColumn {
  ID
  FIRST_NAME
  LAST_NAME
  EMAIL
  CREATED_AT
  FULLNAME
  COMPANY_ID
}

# A paginated list of ApplicantIndividual items.
type ApplicantIndividualPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividual items.
  data: [ApplicantIndividual!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantBankingAccess`.
input QueryApplicantBankingAccessWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantBankingAccessWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantBankingAccessWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantBankingAccessWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantBankingAccessWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantBankingAccess.where.
enum QueryApplicantBankingAccessWhereColumn {
  APPLICANT_INDIVIDUAL_ID
  APPLICANT_COMPANY_ID
  MEMBER_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantBankingAccess`.
input QueryApplicantBankingAccessWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantBankingAccessWhereWhereConditions
}

# Order by clause for Query.applicantBankingAccess.orderBy.
input QueryApplicantBankingAccessOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantBankingAccessOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantBankingAccess.orderBy.
enum QueryApplicantBankingAccessOrderByColumn {
  ID
  APPLICANT_INDIVIDUAL_ID
  APPLICANT_COMPANY_ID
  MEMBER_ID
}

# A paginated list of ApplicantBankingAccess items.
type ApplicantBankingAccessPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantBankingAccess items.
  data: [ApplicantBankingAccess!]!
}

# Access for Online Banking
type ApplicantBankingAccess {
  id: ID!

  # Получить связанного applicant individual
  applicant_individual: ApplicantIndividual

  # Получить связанного applicant company
  applicant_company: ApplicantCompany

  # Получить связанного Member
  member: Members

  # Может создать платеж
  can_create_payment: Boolean!

  # Может подписать платеж
  can_sign_payment: Boolean!

  # Contact administrator
  contact_administrator: Boolean!

  # Ежедневный лимит
  daily_limit: Float!

  # Ежемесячный лимит
  monthly_limit: Float!

  # Лимит операций
  operation_limit: Float!

  # Использованный лимит
  day_used_limit: Float
  month_used_limit: Float
}

# Dynamic WHERE conditions for the `hasGroupRole` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasGroupRoleWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasGroupRoleColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasGroupRoleWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasGroupRoleWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasGroupRoleWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasGroupRole.
enum QueryApplicantCompaniesHasGroupRoleColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupRole` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasGroupRoleWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasGroupRoleWhereHasConditions
}

# Dynamic WHERE conditions for the `hasRiskLevel` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasRiskLevelWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasRiskLevelColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasRiskLevelWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasRiskLevelWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasRiskLevelWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasRiskLevel.
enum QueryApplicantCompaniesHasRiskLevelColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasRiskLevel` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasRiskLevelWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasRiskLevelWhereHasConditions
}

# Dynamic WHERE conditions for the `hasStateReason` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasStateReasonWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasStateReasonColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasStateReasonWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasStateReasonWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasStateReasonWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasStateReason.
enum QueryApplicantCompaniesHasStateReasonColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasStateReason` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasStateReasonWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasStateReasonWhereHasConditions
}

# Dynamic WHERE conditions for the `hasStatus` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasStatusWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasStatusColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasStatusWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasStatusWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasStatusWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasStatus.
enum QueryApplicantCompaniesHasStatusColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasStatus` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasStatusWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasStatusWhereHasConditions
}

# Dynamic WHERE conditions for the `hasBusinessType` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasBusinessTypeWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasBusinessTypeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasBusinessTypeWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasBusinessTypeWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasBusinessTypeWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasBusinessType.
enum QueryApplicantCompaniesHasBusinessTypeColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasBusinessType` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasBusinessTypeWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasBusinessTypeWhereHasConditions
}

# Dynamic WHERE conditions for the `hasOwner` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasOwnerWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasOwnerColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasOwnerWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasOwnerWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasOwnerWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasOwner.
enum QueryApplicantCompaniesHasOwnerColumn {
  FULLNAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasOwner` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasOwnerWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasOwnerWhereHasConditions
}

# Dynamic WHERE conditions for the `hasKycLevel` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasKycLevelWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasKycLevelColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasKycLevelWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasKycLevelWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasKycLevelWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasKycLevel.
enum QueryApplicantCompaniesHasKycLevelColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasKycLevel` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasKycLevelWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasKycLevelWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanies.where.
enum QueryApplicantCompaniesWhereColumn {
  ID
  ACCOUNT_MANAGER_MEMBER_ID
  APPLICANT_STATE_ID
  APPLICANT_STATE_REASON_ID
  NAME
  URL
  EMAIL
  CREATED_AT
  GROUP_ID
  COMPANY_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesWhereWhereConditions
}

# Order by clause for Query.applicantCompanies.orderBy.
input QueryApplicantCompaniesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompaniesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanies.orderBy.
enum QueryApplicantCompaniesOrderByColumn {
  ID
  NAME
  EMAIL
  CREATED_AT
  URL
  OWNER_ID
  COMPANY_ID
}

# A paginated list of ApplicantCompany items.
type ApplicantCompanyPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompany items.
  data: [ApplicantCompany!]!
}

# Order by clause for Query.getMatchedUsers.orderBy.
input QueryGetMatchedUsersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryGetMatchedUsersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.getMatchedUsers.orderBy.
enum QueryGetMatchedUsersOrderByColumn {
  ID
}

# A paginated list of ApplicantIndividualCompany items.
type ApplicantIndividualCompanyPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualCompany items.
  data: [ApplicantIndividualCompany!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanyBusinessType`.
input QueryApplicantCompanyBusinessTypeWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompanyBusinessTypeWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompanyBusinessTypeWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompanyBusinessTypeWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompanyBusinessTypeWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanyBusinessType.where.
enum QueryApplicantCompanyBusinessTypeWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanyBusinessType`.
input QueryApplicantCompanyBusinessTypeWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompanyBusinessTypeWhereWhereConditions
}

# Order by clause for Query.applicantCompanyBusinessType.orderBy.
input QueryApplicantCompanyBusinessTypeOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyBusinessTypeOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyBusinessType.orderBy.
enum QueryApplicantCompanyBusinessTypeOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantCompanyBusinessType items.
type ApplicantCompanyBusinessTypePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyBusinessType items.
  data: [ApplicantCompanyBusinessType!]!
}

# Order by clause for Query.applicantCompanyLabelsAvailable.orderBy.
input QueryApplicantCompanyLabelsAvailableOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyLabelsAvailableOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyLabelsAvailable.orderBy.
enum QueryApplicantCompanyLabelsAvailableOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantCompanyLabel items.
type ApplicantCompanyLabelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyLabel items.
  data: [ApplicantCompanyLabel!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanyModules`.
input QueryApplicantCompanyModulesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompanyModulesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompanyModulesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompanyModulesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompanyModulesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanyModules.where.
enum QueryApplicantCompanyModulesWhereColumn {
  APPLICANT_COMPANY_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanyModules`.
input QueryApplicantCompanyModulesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompanyModulesWhereWhereConditions
}

# Order by clause for Query.applicantCompanyModules.orderBy.
input QueryApplicantCompanyModulesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyModulesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyModules.orderBy.
enum QueryApplicantCompanyModulesOrderByColumn {
  APPLICANT_COMPANY_ID
}

# A paginated list of ApplicantCompanyModules items.
type ApplicantCompanyModulesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyModules items.
  data: [ApplicantCompanyModules!]!
}

# Order by clause for Query.applicantCompanyNotes.orderBy.
input QueryApplicantCompanyNotesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyNotesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyNotes.orderBy.
enum QueryApplicantCompanyNotesOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of ApplicantCompanyNotes items.
type ApplicantCompanyNotesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyNotes items.
  data: [ApplicantCompanyNotes!]!
}

# Order by clause for Query.applicantCompanyRiskLevels.orderBy.
input QueryApplicantCompanyRiskLevelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyRiskLevelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyRiskLevels.orderBy.
enum QueryApplicantCompanyRiskLevelsOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of ApplicantCompanyRiskLevel items.
type ApplicantCompanyRiskLevelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyRiskLevel items.
  data: [ApplicantCompanyRiskLevel!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanyRiskLevelHistory`.
input QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompanyRiskLevelHistoryWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompanyRiskLevelHistoryWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanyRiskLevelHistory.where.
enum QueryApplicantCompanyRiskLevelHistoryWhereColumn {
  RISK_LEVEL_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanyRiskLevelHistory`.
input QueryApplicantCompanyRiskLevelHistoryWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions
}

# Order by clause for Query.applicantCompanyRiskLevelHistory.orderBy.
input QueryApplicantCompanyRiskLevelHistoryOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyRiskLevelHistoryOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyRiskLevelHistory.orderBy.
enum QueryApplicantCompanyRiskLevelHistoryOrderByColumn {
  ID
}

# A paginated list of ApplicantCompanyRiskLevelHistory items.
type ApplicantCompanyRiskLevelHistoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyRiskLevelHistory items.
  data: [ApplicantCompanyRiskLevelHistory!]!
}

# История уровней риска Applicant Company
# Applicants -> Individual -> Individual Company Full Profile -> General
type ApplicantCompanyRiskLevelHistory {
  id: ID!

  # Комментарий
  comment: String!

  # Дата создания сообщения
  created_at: DateTime

  # Получить аппликанта
  applicant_company: ApplicantCompany

  # Получить владельца
  manager: Members

  # Получить уровень риска
  risk_level: ApplicantRiskLevel
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantIndividualCompanyPositions`.
input QueryApplicantIndividualCompanyPositionsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualCompanyPositionsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualCompanyPositionsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualCompanyPositionsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualCompanyPositionsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantIndividualCompanyPositions.where.
enum QueryApplicantIndividualCompanyPositionsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantIndividualCompanyPositions`.
input QueryApplicantIndividualCompanyPositionsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualCompanyPositionsWhereWhereConditions
}

# Order by clause for Query.applicantIndividualCompanyPositions.orderBy.
input QueryApplicantIndividualCompanyPositionsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualCompanyPositionsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualCompanyPositions.orderBy.
enum QueryApplicantIndividualCompanyPositionsOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantIndividualCompanyPosition items.
type ApplicantIndividualCompanyPositionPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualCompanyPosition items.
  data: [ApplicantIndividualCompanyPosition!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantIndividualCompanyRelations`.
input QueryApplicantIndividualCompanyRelationsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualCompanyRelationsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualCompanyRelationsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualCompanyRelationsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualCompanyRelationsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantIndividualCompanyRelations.where.
enum QueryApplicantIndividualCompanyRelationsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantIndividualCompanyRelations`.
input QueryApplicantIndividualCompanyRelationsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualCompanyRelationsWhereWhereConditions
}

# Order by clause for Query.applicantIndividualCompanyRelations.orderBy.
input QueryApplicantIndividualCompanyRelationsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualCompanyRelationsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualCompanyRelations.orderBy.
enum QueryApplicantIndividualCompanyRelationsOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantIndividualCompanyRelation items.
type ApplicantIndividualCompanyRelationPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualCompanyRelation items.
  data: [ApplicantIndividualCompanyRelation!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantIndividualModules`.
input QueryApplicantIndividualModulesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualModulesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualModulesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualModulesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualModulesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantIndividualModules.where.
enum QueryApplicantIndividualModulesWhereColumn {
  APPLICANT_INDIVIDUAL_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantIndividualModules`.
input QueryApplicantIndividualModulesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualModulesWhereWhereConditions
}

# Order by clause for Query.applicantIndividualModules.orderBy.
input QueryApplicantIndividualModulesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualModulesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualModules.orderBy.
enum QueryApplicantIndividualModulesOrderByColumn {
  APPLICANT_INDIVIDUAL_ID
}

# A paginated list of ApplicantIndividualModules items.
type ApplicantIndividualModulesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualModules items.
  data: [ApplicantIndividualModules!]!
}

# Order by clause for Query.applicantIndividualRiskLevels.orderBy.
input QueryApplicantIndividualRiskLevelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualRiskLevelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualRiskLevels.orderBy.
enum QueryApplicantIndividualRiskLevelsOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of ApplicantIndividualRiskLevel items.
type ApplicantIndividualRiskLevelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualRiskLevel items.
  data: [ApplicantIndividualRiskLevel!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantRiskLevelHistory`.
input QueryApplicantRiskLevelHistoryWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantRiskLevelHistoryWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantRiskLevelHistoryWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantRiskLevelHistoryWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantRiskLevelHistoryWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantRiskLevelHistory.where.
enum QueryApplicantRiskLevelHistoryWhereColumn {
  RISK_LEVEL_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantRiskLevelHistory`.
input QueryApplicantRiskLevelHistoryWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantRiskLevelHistoryWhereWhereConditions
}

# Order by clause for Query.applicantRiskLevelHistory.orderBy.
input QueryApplicantRiskLevelHistoryOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantRiskLevelHistoryOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantRiskLevelHistory.orderBy.
enum QueryApplicantRiskLevelHistoryOrderByColumn {
  ID
}

# A paginated list of ApplicantRiskLevelHistory items.
type ApplicantRiskLevelHistoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantRiskLevelHistory items.
  data: [ApplicantRiskLevelHistory!]!
}

# История уровней риска Applicant Individual
# Applicants -> Individual -> Individual Full Profile -> General
type ApplicantRiskLevelHistory {
  id: ID!

  # Комментарий
  comment: String!

  # Дата создания сообщения
  created_at: DateTime

  # Получить аппликанта
  applicant: ApplicantIndividual

  # Получить владельца
  manager: Members

  # Получить уровень риска
  risk_level: ApplicantRiskLevel
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantKycLevels`.
input QueryApplicantKycLevelsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantKycLevelsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantKycLevelsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantKycLevelsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantKycLevelsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantKycLevels.where.
enum QueryApplicantKycLevelsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantKycLevels`.
input QueryApplicantKycLevelsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantKycLevelsWhereWhereConditions
}

# Order by clause for Query.applicantKycLevels.orderBy.
input QueryApplicantKycLevelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantKycLevelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantKycLevels.orderBy.
enum QueryApplicantKycLevelsOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantKycLevel items.
type ApplicantKycLevelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantKycLevel items.
  data: [ApplicantKycLevel!]!
}

# Order by clause for Query.applicantIndividualLabelsAvailable.orderBy.
input QueryApplicantIndividualLabelsAvailableOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualLabelsAvailableOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualLabelsAvailable.orderBy.
enum QueryApplicantIndividualLabelsAvailableOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantIndividualLabel items.
type ApplicantIndividualLabelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualLabel items.
  data: [ApplicantIndividualLabel!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicant_modules`.
input QueryApplicantModulesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantModulesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantModulesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantModulesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantModulesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicant_modules.where.
enum QueryApplicantModulesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicant_modules`.
input QueryApplicantModulesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantModulesWhereWhereConditions
}

# Order by clause for Query.applicant_modules.orderBy.
input QueryApplicantModulesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantModulesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicant_modules.orderBy.
enum QueryApplicantModulesOrderByColumn {
  ID
}

# A paginated list of ApplicantModules items.
type ApplicantModulesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantModules items.
  data: [ApplicantModules!]!
}

# Order by clause for Query.applicantIndividualNotes.orderBy.
input QueryApplicantIndividualNotesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualNotesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualNotes.orderBy.
enum QueryApplicantIndividualNotesOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of ApplicantIndividualNotes items.
type ApplicantIndividualNotesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualNotes items.
  data: [ApplicantIndividualNotes!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantRiskLevels`.
input QueryApplicantRiskLevelsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantRiskLevelsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantRiskLevelsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantRiskLevelsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantRiskLevelsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantRiskLevels.where.
enum QueryApplicantRiskLevelsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantRiskLevels`.
input QueryApplicantRiskLevelsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantRiskLevelsWhereWhereConditions
}

# Order by clause for Query.applicantRiskLevels.orderBy.
input QueryApplicantRiskLevelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantRiskLevelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantRiskLevels.orderBy.
enum QueryApplicantRiskLevelsOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantRiskLevel items.
type ApplicantRiskLevelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantRiskLevel items.
  data: [ApplicantRiskLevel!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantStates`.
input QueryApplicantStatesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantStatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantStatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantStatesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantStatesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantStates.where.
enum QueryApplicantStatesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantStates`.
input QueryApplicantStatesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantStatesWhereWhereConditions
}

# Order by clause for Query.applicantStates.orderBy.
input QueryApplicantStatesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantStatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantStates.orderBy.
enum QueryApplicantStatesOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantState items.
type ApplicantStatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantState items.
  data: [ApplicantState!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantStateReasons`.
input QueryApplicantStateReasonsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantStateReasonsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantStateReasonsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantStateReasonsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantStateReasonsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantStateReasons.where.
enum QueryApplicantStateReasonsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantStateReasons`.
input QueryApplicantStateReasonsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantStateReasonsWhereWhereConditions
}

# Order by clause for Query.applicantStateReasons.orderBy.
input QueryApplicantStateReasonsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantStateReasonsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantStateReasons.orderBy.
enum QueryApplicantStateReasonsOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantStateReason items.
type ApplicantStateReasonPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantStateReason items.
  data: [ApplicantStateReason!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantStatuses`.
input QueryApplicantStatusesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantStatusesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantStatusesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantStatusesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantStatusesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantStatuses.where.
enum QueryApplicantStatusesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantStatuses`.
input QueryApplicantStatusesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantStatusesWhereWhereConditions
}

# Order by clause for Query.applicantStatuses.orderBy.
input QueryApplicantStatusesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantStatusesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantStatuses.orderBy.
enum QueryApplicantStatusesOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantStatus items.
type ApplicantStatusPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantStatus items.
  data: [ApplicantStatus!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `businessActivities`.
input QueryBusinessActivitiesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryBusinessActivitiesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryBusinessActivitiesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryBusinessActivitiesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryBusinessActivitiesWhereWhereConditionsRelation
}

# Allowed column names for Query.businessActivities.where.
enum QueryBusinessActivitiesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `businessActivities`.
input QueryBusinessActivitiesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryBusinessActivitiesWhereWhereConditions
}

# Order by clause for Query.businessActivities.orderBy.
input QueryBusinessActivitiesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryBusinessActivitiesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.businessActivities.orderBy.
enum QueryBusinessActivitiesOrderByColumn {
  ID
  NAME
}

# A paginated list of BusinessActivity items.
type BusinessActivityPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of BusinessActivity items.
  data: [BusinessActivity!]!
}

# Dynamic WHERE conditions for the `hasPaymentSystem` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasPaymentSystemWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionPriceListsHasPaymentSystemColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionPriceListsHasPaymentSystemWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionPriceListsHasPaymentSystemWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionPriceListsHasPaymentSystemWhereHasConditionsRelation
}

# Allowed column names for Query.commissionPriceLists.hasPaymentSystem.
enum QueryCommissionPriceListsHasPaymentSystemColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentSystem` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasPaymentSystemWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionPriceListsHasPaymentSystemWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCommissionTemplate` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasCommissionTemplateWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionPriceListsHasCommissionTemplateColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionPriceListsHasCommissionTemplateWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionPriceListsHasCommissionTemplateWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionPriceListsHasCommissionTemplateWhereHasConditionsRelation
}

# Allowed column names for Query.commissionPriceLists.hasCommissionTemplate.
enum QueryCommissionPriceListsHasCommissionTemplateColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasCommissionTemplate` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasCommissionTemplateWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionPriceListsHasCommissionTemplateWhereHasConditions
}

# Dynamic WHERE conditions for the `hasOwner` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasOwnerWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionPriceListsHasOwnerColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionPriceListsHasOwnerWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionPriceListsHasOwnerWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionPriceListsHasOwnerWhereHasConditionsRelation
}

# Allowed column names for Query.commissionPriceLists.hasOwner.
enum QueryCommissionPriceListsHasOwnerColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasOwner` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasOwnerWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionPriceListsHasOwnerWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCompany` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasCompanyWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionPriceListsHasCompanyColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionPriceListsHasCompanyWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionPriceListsHasCompanyWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionPriceListsHasCompanyWhereHasConditionsRelation
}

# Allowed column names for Query.commissionPriceLists.hasCompany.
enum QueryCommissionPriceListsHasCompanyColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasCompany` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasCompanyWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionPriceListsHasCompanyWhereHasConditions
}

# Dynamic WHERE conditions for the `hasAccount` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasAccountWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionPriceListsHasAccountColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionPriceListsHasAccountWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionPriceListsHasAccountWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionPriceListsHasAccountWhereHasConditionsRelation
}

# Allowed column names for Query.commissionPriceLists.hasAccount.
enum QueryCommissionPriceListsHasAccountColumn {
  ACCOUNT_NUMBER
}

# Dynamic HAS conditions for WHERE conditions for the `hasAccount` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasAccountWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionPriceListsHasAccountWhereHasConditions
}

# Dynamic WHERE conditions for the `hasPaymentProvider` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasPaymentProviderWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionPriceListsHasPaymentProviderColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionPriceListsHasPaymentProviderWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionPriceListsHasPaymentProviderWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionPriceListsHasPaymentProviderWhereHasConditionsRelation
}

# Allowed column names for Query.commissionPriceLists.hasPaymentProvider.
enum QueryCommissionPriceListsHasPaymentProviderColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentProvider` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsHasPaymentProviderWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionPriceListsHasPaymentProviderWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionPriceListsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionPriceListsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionPriceListsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionPriceListsWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionPriceLists.where.
enum QueryCommissionPriceListsWhereColumn {
  NAME
  PAYMENT_SYSTEM_ID
  COMMISSION_TEMPLATE_ID
  PROVIDER_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionPriceListsWhereWhereConditions
}

# Order by clause for Query.commissionPriceLists.orderBy.
input QueryCommissionPriceListsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionPriceListsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionPriceLists.orderBy.
enum QueryCommissionPriceListsOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionPriceList items.
type CommissionPriceListPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionPriceList items.
  data: [CommissionPriceList!]!
}

# Dynamic WHERE conditions for the `hasPaymentProvider` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasPaymentProviderWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplatesHasPaymentProviderColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplatesHasPaymentProviderWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplatesHasPaymentProviderWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplatesHasPaymentProviderWhereHasConditionsRelation
}

# Allowed column names for Query.commissionTemplates.hasPaymentProvider.
enum QueryCommissionTemplatesHasPaymentProviderColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentProvider` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasPaymentProviderWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplatesHasPaymentProviderWhereHasConditions
}

# Dynamic WHERE conditions for the `hasBusinessActivity` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasBusinessActivityWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplatesHasBusinessActivityColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplatesHasBusinessActivityWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplatesHasBusinessActivityWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplatesHasBusinessActivityWhereHasConditionsRelation
}

# Allowed column names for Query.commissionTemplates.hasBusinessActivity.
enum QueryCommissionTemplatesHasBusinessActivityColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasBusinessActivity` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasBusinessActivityWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplatesHasBusinessActivityWhereHasConditions
}

# Dynamic WHERE conditions for the `hasOwner` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasOwnerWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplatesHasOwnerColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplatesHasOwnerWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplatesHasOwnerWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplatesHasOwnerWhereHasConditionsRelation
}

# Allowed column names for Query.commissionTemplates.hasOwner.
enum QueryCommissionTemplatesHasOwnerColumn {
  FULLNAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasOwner` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasOwnerWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplatesHasOwnerWhereHasConditions
}

# Dynamic WHERE conditions for the `hasAccount` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasAccountWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplatesHasAccountColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplatesHasAccountWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplatesHasAccountWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplatesHasAccountWhereHasConditionsRelation
}

# Allowed column names for Query.commissionTemplates.hasAccount.
enum QueryCommissionTemplatesHasAccountColumn {
  ACCOUNT_NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasAccount` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasAccountWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplatesHasAccountWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCompany` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasCompanyWhereHasConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplatesHasCompanyColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplatesHasCompanyWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplatesHasCompanyWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplatesHasCompanyWhereHasConditionsRelation
}

# Allowed column names for Query.commissionTemplates.hasCompany.
enum QueryCommissionTemplatesHasCompanyColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCompany` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesHasCompanyWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplatesHasCompanyWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplatesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplatesWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplates.where.
enum QueryCommissionTemplatesWhereColumn {
  ID
  NAME
  IS_ACTIVE
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplatesWhereWhereConditions
}

# Order by clause for Query.commissionTemplates.orderBy.
input QueryCommissionTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplates.orderBy.
enum QueryCommissionTemplatesOrderByColumn {
  ID
  NAME
  IS_ACTIVE
  DESCRIPTION
}

# A paginated list of CommissionTemplate items.
type CommissionTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplate items.
  data: [CommissionTemplate!]!
}

# A paginated list of CommissionTemplateLimit items.
type CommissionTemplateLimitPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimit items.
  data: [CommissionTemplateLimit!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplateLimitActionType`.
input QueryCommissionTemplateLimitActionTypeWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplateLimitActionTypeWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplateLimitActionTypeWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplateLimitActionTypeWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplateLimitActionTypeWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplateLimitActionType.where.
enum QueryCommissionTemplateLimitActionTypeWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplateLimitActionType`.
input QueryCommissionTemplateLimitActionTypeWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplateLimitActionTypeWhereWhereConditions
}

# Order by clause for Query.commissionTemplateLimitActionType.orderBy.
input QueryCommissionTemplateLimitActionTypeOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplateLimitActionTypeOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplateLimitActionType.orderBy.
enum QueryCommissionTemplateLimitActionTypeOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionTemplateLimitActionType items.
type CommissionTemplateLimitActionTypePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimitActionType items.
  data: [CommissionTemplateLimitActionType!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplateLimitPeriods`.
input QueryCommissionTemplateLimitPeriodsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplateLimitPeriodsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplateLimitPeriodsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplateLimitPeriodsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplateLimitPeriodsWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplateLimitPeriods.where.
enum QueryCommissionTemplateLimitPeriodsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplateLimitPeriods`.
input QueryCommissionTemplateLimitPeriodsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplateLimitPeriodsWhereWhereConditions
}

# Order by clause for Query.commissionTemplateLimitPeriods.orderBy.
input QueryCommissionTemplateLimitPeriodsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplateLimitPeriodsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplateLimitPeriods.orderBy.
enum QueryCommissionTemplateLimitPeriodsOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionTemplateLimitPeriod items.
type CommissionTemplateLimitPeriodPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimitPeriod items.
  data: [CommissionTemplateLimitPeriod!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplateLimitTransferDirections`.
input QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplateLimitTransferDirectionsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplateLimitTransferDirections.where.
enum QueryCommissionTemplateLimitTransferDirectionsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplateLimitTransferDirections`.
input QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions
}

# Order by clause for Query.commissionTemplateLimitTransferDirections.orderBy.
input QueryCommissionTemplateLimitTransferDirectionsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplateLimitTransferDirectionsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplateLimitTransferDirections.orderBy.
enum QueryCommissionTemplateLimitTransferDirectionsOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionTemplateLimitTransferDirection items.
type CommissionTemplateLimitTransferDirectionPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimitTransferDirection items.
  data: [CommissionTemplateLimitTransferDirection!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplateLimitTypes`.
input QueryCommissionTemplateLimitTypesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplateLimitTypesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplateLimitTypesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplateLimitTypesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplateLimitTypesWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplateLimitTypes.where.
enum QueryCommissionTemplateLimitTypesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplateLimitTypes`.
input QueryCommissionTemplateLimitTypesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplateLimitTypesWhereWhereConditions
}

# Order by clause for Query.commissionTemplateLimitTypes.orderBy.
input QueryCommissionTemplateLimitTypesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplateLimitTypesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplateLimitTypes.orderBy.
enum QueryCommissionTemplateLimitTypesOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionTemplateLimitType items.
type CommissionTemplateLimitTypePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimitType items.
  data: [CommissionTemplateLimitType!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `companies`.
input QueryCompaniesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCompaniesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCompaniesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCompaniesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCompaniesWhereWhereConditionsRelation
}

# Allowed column names for Query.companies.where.
enum QueryCompaniesWhereColumn {
  NAME
  EMAIL
  URL
  CREATED_AT
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `companies`.
input QueryCompaniesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCompaniesWhereWhereConditions
}

# Order by clause for Query.companies.orderBy.
input QueryCompaniesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCompaniesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.companies.orderBy.
enum QueryCompaniesOrderByColumn {
  ID
  CREATED_AT
  NAME
  EMAIL
  URL
}

# A paginated list of Companies items.
type CompaniesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Companies items.
  data: [Companies!]!
}

# A paginated list of Country items.
type CountryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Country items.
  data: [Country!]!
}

# A paginated list of Currencies items.
type CurrenciesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Currencies items.
  data: [Currencies!]!
}

# Dynamic WHERE conditions for the `hasCompany` argument on the query `departments`.
input QueryDepartmentsHasCompanyWhereHasConditions {
  # The column that is used for the condition.
  column: QueryDepartmentsHasCompanyColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryDepartmentsHasCompanyWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryDepartmentsHasCompanyWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryDepartmentsHasCompanyWhereHasConditionsRelation
}

# Allowed column names for Query.departments.hasCompany.
enum QueryDepartmentsHasCompanyColumn {
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasCompany` argument on the query `departments`.
input QueryDepartmentsHasCompanyWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryDepartmentsHasCompanyWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `departments`.
input QueryDepartmentsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryDepartmentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryDepartmentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryDepartmentsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryDepartmentsWhereWhereConditionsRelation
}

# Allowed column names for Query.departments.where.
enum QueryDepartmentsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `departments`.
input QueryDepartmentsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryDepartmentsWhereWhereConditions
}

# Order by clause for Query.departments.orderBy.
input QueryDepartmentsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryDepartmentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.departments.orderBy.
enum QueryDepartmentsOrderByColumn {
  ID
  NAME
}

# A paginated list of Departments items.
type DepartmentsPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Departments items.
  data: [Departments!]!
}

# Dynamic WHERE conditions for the `hasDepartment` argument on the query `departmentPositions`.
input QueryDepartmentPositionsHasDepartmentWhereHasConditions {
  # The column that is used for the condition.
  column: QueryDepartmentPositionsHasDepartmentColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryDepartmentPositionsHasDepartmentWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryDepartmentPositionsHasDepartmentWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryDepartmentPositionsHasDepartmentWhereHasConditionsRelation
}

# Allowed column names for Query.departmentPositions.hasDepartment.
enum QueryDepartmentPositionsHasDepartmentColumn {
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasDepartment` argument on the query `departmentPositions`.
input QueryDepartmentPositionsHasDepartmentWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryDepartmentPositionsHasDepartmentWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `departmentPositions`.
input QueryDepartmentPositionsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryDepartmentPositionsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryDepartmentPositionsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryDepartmentPositionsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryDepartmentPositionsWhereWhereConditionsRelation
}

# Allowed column names for Query.departmentPositions.where.
enum QueryDepartmentPositionsWhereColumn {
  NAME
  IS_ACTIVE
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `departmentPositions`.
input QueryDepartmentPositionsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryDepartmentPositionsWhereWhereConditions
}

# Order by clause for Query.departmentPositions.orderBy.
input QueryDepartmentPositionsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryDepartmentPositionsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.departmentPositions.orderBy.
enum QueryDepartmentPositionsOrderByColumn {
  ID
  NAME
  IS_ACTIVE
}

# A paginated list of DepartmentPosition items.
type DepartmentPositionPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of DepartmentPosition items.
  data: [DepartmentPosition!]!
}

# Dynamic WHERE conditions for the `hasApplicantIndividual` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasApplicantIndividualWhereHasConditions {
  # The column that is used for the condition.
  column: QueryEmailNotificationsHasApplicantIndividualColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailNotificationsHasApplicantIndividualWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailNotificationsHasApplicantIndividualWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailNotificationsHasApplicantIndividualWhereHasConditionsRelation
}

# Allowed column names for Query.emailNotifications.hasApplicantIndividual.
enum QueryEmailNotificationsHasApplicantIndividualColumn {
  ID
  FULLNAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasApplicantIndividual` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasApplicantIndividualWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailNotificationsHasApplicantIndividualWhereHasConditions
}

# Dynamic WHERE conditions for the `hasApplicantCompany` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasApplicantCompanyWhereHasConditions {
  # The column that is used for the condition.
  column: QueryEmailNotificationsHasApplicantCompanyColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailNotificationsHasApplicantCompanyWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailNotificationsHasApplicantCompanyWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailNotificationsHasApplicantCompanyWhereHasConditionsRelation
}

# Allowed column names for Query.emailNotifications.hasApplicantCompany.
enum QueryEmailNotificationsHasApplicantCompanyColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasApplicantCompany` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasApplicantCompanyWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailNotificationsHasApplicantCompanyWhereHasConditions
}

# Dynamic WHERE conditions for the `hasGroupRole` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasGroupRoleWhereHasConditions {
  # The column that is used for the condition.
  column: QueryEmailNotificationsHasGroupRoleColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailNotificationsHasGroupRoleWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailNotificationsHasGroupRoleWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailNotificationsHasGroupRoleWhereHasConditionsRelation
}

# Allowed column names for Query.emailNotifications.hasGroupRole.
enum QueryEmailNotificationsHasGroupRoleColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupRole` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasGroupRoleWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailNotificationsHasGroupRoleWhereHasConditions
}

# Dynamic WHERE conditions for the `hasMember` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasMemberWhereHasConditions {
  # The column that is used for the condition.
  column: QueryEmailNotificationsHasMemberColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailNotificationsHasMemberWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailNotificationsHasMemberWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailNotificationsHasMemberWhereHasConditionsRelation
}

# Allowed column names for Query.emailNotifications.hasMember.
enum QueryEmailNotificationsHasMemberColumn {
  ID
  FULLNAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasMember` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasMemberWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailNotificationsHasMemberWhereHasConditions
}

# Dynamic WHERE conditions for the `hasGroupType` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasGroupTypeWhereHasConditions {
  # The column that is used for the condition.
  column: QueryEmailNotificationsHasGroupTypeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailNotificationsHasGroupTypeWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailNotificationsHasGroupTypeWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailNotificationsHasGroupTypeWhereHasConditionsRelation
}

# Allowed column names for Query.emailNotifications.hasGroupType.
enum QueryEmailNotificationsHasGroupTypeColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupType` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasGroupTypeWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailNotificationsHasGroupTypeWhereHasConditions
}

# Dynamic WHERE conditions for the `hasTemplates` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasTemplatesWhereHasConditions {
  # The column that is used for the condition.
  column: QueryEmailNotificationsHasTemplatesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailNotificationsHasTemplatesWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailNotificationsHasTemplatesWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailNotificationsHasTemplatesWhereHasConditionsRelation
}

# Allowed column names for Query.emailNotifications.hasTemplates.
enum QueryEmailNotificationsHasTemplatesColumn {
  SUBJECT
}

# Dynamic HAS conditions for WHERE conditions for the `hasTemplates` argument on the query `emailNotifications`.
input QueryEmailNotificationsHasTemplatesWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailNotificationsHasTemplatesWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `emailNotifications`.
input QueryEmailNotificationsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryEmailNotificationsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailNotificationsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailNotificationsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailNotificationsWhereWhereConditionsRelation
}

# Allowed column names for Query.emailNotifications.where.
enum QueryEmailNotificationsWhereColumn {
  TYPE
  COMPANY_ID
  RECIPIENT_TYPE
  GROUP_TYPE
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `emailNotifications`.
input QueryEmailNotificationsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailNotificationsWhereWhereConditions
}

# Order by clause for Query.emailNotifications.orderBy.
input QueryEmailNotificationsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryEmailNotificationsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.emailNotifications.orderBy.
enum QueryEmailNotificationsOrderByColumn {
  ID
}

# A paginated list of EmailNotification items.
type EmailNotificationPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of EmailNotification items.
  data: [EmailNotification!]!
}

# Dynamic WHERE conditions for the `hasCompany` argument on the query `emailTemplates`.
input QueryEmailTemplatesHasCompanyWhereHasConditions {
  # The column that is used for the condition.
  column: QueryEmailTemplatesHasCompanyColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailTemplatesHasCompanyWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailTemplatesHasCompanyWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailTemplatesHasCompanyWhereHasConditionsRelation
}

# Allowed column names for Query.emailTemplates.hasCompany.
enum QueryEmailTemplatesHasCompanyColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCompany` argument on the query `emailTemplates`.
input QueryEmailTemplatesHasCompanyWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailTemplatesHasCompanyWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `emailTemplates`.
input QueryEmailTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryEmailTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailTemplatesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryEmailTemplatesWhereWhereConditionsRelation
}

# Allowed column names for Query.emailTemplates.where.
enum QueryEmailTemplatesWhereColumn {
  NAME
  COMPANY_ID
  TYPE
  SERVICE_TYPE
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `emailTemplates`.
input QueryEmailTemplatesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryEmailTemplatesWhereWhereConditions
}

# Order by clause for Query.emailTemplates.orderBy.
input QueryEmailTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryEmailTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.emailTemplates.orderBy.
enum QueryEmailTemplatesOrderByColumn {
  ID
}

# A paginated list of EmailTemplate items.
type EmailTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of EmailTemplate items.
  data: [EmailTemplate!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `files`.
input QueryFilesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryFilesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryFilesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryFilesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryFilesWhereWhereConditionsRelation
}

# Allowed column names for Query.files.where.
enum QueryFilesWhereColumn {
  AUTHOR_ID
  ENTITY_TYPE
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `files`.
input QueryFilesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryFilesWhereWhereConditions
}

# Order by clause for Query.files.orderBy.
input QueryFilesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryFilesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.files.orderBy.
enum QueryFilesOrderByColumn {
  ID
  AUTHOR_ID
}

# A paginated list of Files items.
type FilesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Files items.
  data: [Files!]!
}

# Dynamic WHERE conditions for the `hasPaymentProvider` argument on the query `groups`.
input QueryGroupsHasPaymentProviderWhereHasConditions {
  # The column that is used for the condition.
  column: QueryGroupsHasPaymentProviderColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGroupsHasPaymentProviderWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGroupsHasPaymentProviderWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryGroupsHasPaymentProviderWhereHasConditionsRelation
}

# Allowed column names for Query.groups.hasPaymentProvider.
enum QueryGroupsHasPaymentProviderColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentProvider` argument on the query `groups`.
input QueryGroupsHasPaymentProviderWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryGroupsHasPaymentProviderWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCommissionTemplate` argument on the query `groups`.
input QueryGroupsHasCommissionTemplateWhereHasConditions {
  # The column that is used for the condition.
  column: QueryGroupsHasCommissionTemplateColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGroupsHasCommissionTemplateWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGroupsHasCommissionTemplateWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryGroupsHasCommissionTemplateWhereHasConditionsRelation
}

# Allowed column names for Query.groups.hasCommissionTemplate.
enum QueryGroupsHasCommissionTemplateColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasCommissionTemplate` argument on the query `groups`.
input QueryGroupsHasCommissionTemplateWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryGroupsHasCommissionTemplateWhereHasConditions
}

# Dynamic WHERE conditions for the `hasGroupType` argument on the query `groups`.
input QueryGroupsHasGroupTypeWhereHasConditions {
  # The column that is used for the condition.
  column: QueryGroupsHasGroupTypeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGroupsHasGroupTypeWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGroupsHasGroupTypeWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryGroupsHasGroupTypeWhereHasConditionsRelation
}

# Allowed column names for Query.groups.hasGroupType.
enum QueryGroupsHasGroupTypeColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupType` argument on the query `groups`.
input QueryGroupsHasGroupTypeWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryGroupsHasGroupTypeWhereHasConditions
}

# Dynamic WHERE conditions for the `hasRole` argument on the query `groups`.
input QueryGroupsHasRoleWhereHasConditions {
  # The column that is used for the condition.
  column: QueryGroupsHasRoleColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGroupsHasRoleWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGroupsHasRoleWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryGroupsHasRoleWhereHasConditionsRelation
}

# Allowed column names for Query.groups.hasRole.
enum QueryGroupsHasRoleColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasRole` argument on the query `groups`.
input QueryGroupsHasRoleWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryGroupsHasRoleWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `groups`.
input QueryGroupsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryGroupsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGroupsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGroupsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryGroupsWhereWhereConditionsRelation
}

# Allowed column names for Query.groups.where.
enum QueryGroupsWhereColumn {
  ID
  GROUP_TYPE_ID
  NAME
  ROLE_ID
  PAYMENT_PROVIDER_ID
  COMMISSION_TEMPLATE_ID
  IS_ACTIVE
  COMPANY_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `groups`.
input QueryGroupsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryGroupsWhereWhereConditions
}

# Order by clause for Query.groups.orderBy.
input QueryGroupsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryGroupsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.groups.orderBy.
enum QueryGroupsOrderByColumn {
  ID
  IS_ACTIVE
  DESCRIPTION
}

# A paginated list of GroupRole items.
type GroupRolePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of GroupRole items.
  data: [GroupRole!]!
}

input QueryGroupCondition {
  id: ID
  company_id: ID
  payment_provider_id: ID
  name: String
  role_id: ID
  group_type_id: ID
  commission_template_id: ID
  is_active: Boolean
}

# Order by clause for Query.groupList.orderBy.
input QueryGroupListOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryGroupListOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.groupList.orderBy.
enum QueryGroupListOrderByColumn {
  ID
  IS_ACTIVE
  NAME
}

# Dynamic WHERE conditions for the `hasGroupRole` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsHasGroupRoleWhereHasConditions {
  # The column that is used for the condition.
  column: QueryMemberAccessLimitationsHasGroupRoleColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMemberAccessLimitationsHasGroupRoleWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMemberAccessLimitationsHasGroupRoleWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryMemberAccessLimitationsHasGroupRoleWhereHasConditionsRelation
}

# Allowed column names for Query.memberAccessLimitations.hasGroupRole.
enum QueryMemberAccessLimitationsHasGroupRoleColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupRole` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsHasGroupRoleWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryMemberAccessLimitationsHasGroupRoleWhereHasConditions
}

# Dynamic WHERE conditions for the `hasGroup` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsHasGroupWhereHasConditions {
  # The column that is used for the condition.
  column: QueryMemberAccessLimitationsHasGroupColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMemberAccessLimitationsHasGroupWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMemberAccessLimitationsHasGroupWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryMemberAccessLimitationsHasGroupWhereHasConditionsRelation
}

# Allowed column names for Query.memberAccessLimitations.hasGroup.
enum QueryMemberAccessLimitationsHasGroupColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroup` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsHasGroupWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryMemberAccessLimitationsHasGroupWhereHasConditions
}

# Dynamic WHERE conditions for the `hasProvider` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsHasProviderWhereHasConditions {
  # The column that is used for the condition.
  column: QueryMemberAccessLimitationsHasProviderColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMemberAccessLimitationsHasProviderWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMemberAccessLimitationsHasProviderWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryMemberAccessLimitationsHasProviderWhereHasConditionsRelation
}

# Allowed column names for Query.memberAccessLimitations.hasProvider.
enum QueryMemberAccessLimitationsHasProviderColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasProvider` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsHasProviderWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryMemberAccessLimitationsHasProviderWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCommissionTemplate` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsHasCommissionTemplateWhereHasConditions {
  # The column that is used for the condition.
  column: QueryMemberAccessLimitationsHasCommissionTemplateColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMemberAccessLimitationsHasCommissionTemplateWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMemberAccessLimitationsHasCommissionTemplateWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryMemberAccessLimitationsHasCommissionTemplateWhereHasConditionsRelation
}

# Allowed column names for Query.memberAccessLimitations.hasCommissionTemplate.
enum QueryMemberAccessLimitationsHasCommissionTemplateColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCommissionTemplate` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsHasCommissionTemplateWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryMemberAccessLimitationsHasCommissionTemplateWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryMemberAccessLimitationsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMemberAccessLimitationsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMemberAccessLimitationsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryMemberAccessLimitationsWhereWhereConditionsRelation
}

# Allowed column names for Query.memberAccessLimitations.where.
enum QueryMemberAccessLimitationsWhereColumn {
  ID
  MEMBER_ID
  GROUP_ROLE_ID
  PROVIDER_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryMemberAccessLimitationsWhereWhereConditions
}

# Order by clause for Query.memberAccessLimitations.orderBy.
input QueryMemberAccessLimitationsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryMemberAccessLimitationsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.memberAccessLimitations.orderBy.
enum QueryMemberAccessLimitationsOrderByColumn {
  ID
}

# A paginated list of MemberAccessLimitation items.
type MemberAccessLimitationPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of MemberAccessLimitation items.
  data: [MemberAccessLimitation!]!
}

# Dynamic WHERE conditions for the `hasDepartment` argument on the query `members`.
input QueryMembersHasDepartmentWhereHasConditions {
  # The column that is used for the condition.
  column: QueryMembersHasDepartmentColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMembersHasDepartmentWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMembersHasDepartmentWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryMembersHasDepartmentWhereHasConditionsRelation
}

# Allowed column names for Query.members.hasDepartment.
enum QueryMembersHasDepartmentColumn {
  DEPARTMENT_ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasDepartment` argument on the query `members`.
input QueryMembersHasDepartmentWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryMembersHasDepartmentWhereHasConditions
}

# Dynamic WHERE conditions for the `hasGroupRole` argument on the query `members`.
input QueryMembersHasGroupRoleWhereHasConditions {
  # The column that is used for the condition.
  column: QueryMembersHasGroupRoleColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMembersHasGroupRoleWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMembersHasGroupRoleWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryMembersHasGroupRoleWhereHasConditionsRelation
}

# Allowed column names for Query.members.hasGroupRole.
enum QueryMembersHasGroupRoleColumn {
  GROUP_TYPE_ID
  ROLE_ID
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupRole` argument on the query `members`.
input QueryMembersHasGroupRoleWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryMembersHasGroupRoleWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `members`.
input QueryMembersWhereWhereConditions {
  # The column that is used for the condition.
  column: MembersColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMembersWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMembersWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryMembersWhereWhereConditionsRelation
}

enum MembersColumn {
  ID
  FULLNAME
  COMPANY_ID
  EMAIL
  POSITION_ID
  IS_ACTIVE
  LAST_LOGIN_AT
  IS_SHOW_OWNER_APPLICANTS
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `members`.
input QueryMembersWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryMembersWhereWhereConditions
}

# Order by clause for Query.members.orderBy.
input QueryMembersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryMembersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.members.orderBy.
enum QueryMembersOrderByColumn {
  ID
  EMAIL
  LAST_LOGIN_AT
  IS_ACTIVE
}

# A paginated list of Members items.
type MembersPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Members items.
  data: [Members!]!
}

# Dynamic WHERE conditions for the `hasPaymentSystems` argument on the query `paymentProviders`.
input QueryPaymentProvidersHasPaymentSystemsWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentProvidersHasPaymentSystemsColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentProvidersHasPaymentSystemsWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentProvidersHasPaymentSystemsWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentProvidersHasPaymentSystemsWhereHasConditionsRelation
}

# Allowed column names for Query.paymentProviders.hasPaymentSystems.
enum QueryPaymentProvidersHasPaymentSystemsColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentSystems` argument on the query `paymentProviders`.
input QueryPaymentProvidersHasPaymentSystemsWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentProvidersHasPaymentSystemsWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `paymentProviders`.
input QueryPaymentProvidersWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryPaymentProvidersWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentProvidersWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentProvidersWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentProvidersWhereWhereConditionsRelation
}

# Allowed column names for Query.paymentProviders.where.
enum QueryPaymentProvidersWhereColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `paymentProviders`.
input QueryPaymentProvidersWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentProvidersWhereWhereConditions
}

# Order by clause for Query.paymentProviders.orderBy.
input QueryPaymentProvidersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryPaymentProvidersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.paymentProviders.orderBy.
enum QueryPaymentProvidersOrderByColumn {
  ID
  NAME
  IS_ACTIVE
}

# A paginated list of PaymentProvider items.
type PaymentProviderPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PaymentProvider items.
  data: [PaymentProvider!]!
}

# Dynamic WHERE conditions for the `hasCountries` argument on the query `paymentSystems`.
input QueryPaymentSystemsHasCountriesWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentSystemsHasCountriesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentSystemsHasCountriesWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentSystemsHasCountriesWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentSystemsHasCountriesWhereHasConditionsRelation
}

# Allowed column names for Query.paymentSystems.hasCountries.
enum QueryPaymentSystemsHasCountriesColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasCountries` argument on the query `paymentSystems`.
input QueryPaymentSystemsHasCountriesWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentSystemsHasCountriesWhereHasConditions
}

# Dynamic WHERE conditions for the `hasCurrencies` argument on the query `paymentSystems`.
input QueryPaymentSystemsHasCurrenciesWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentSystemsHasCurrenciesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentSystemsHasCurrenciesWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentSystemsHasCurrenciesWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentSystemsHasCurrenciesWhereHasConditionsRelation
}

# Allowed column names for Query.paymentSystems.hasCurrencies.
enum QueryPaymentSystemsHasCurrenciesColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasCurrencies` argument on the query `paymentSystems`.
input QueryPaymentSystemsHasCurrenciesWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentSystemsHasCurrenciesWhereHasConditions
}

# Dynamic WHERE conditions for the `hasProviders` argument on the query `paymentSystems`.
input QueryPaymentSystemsHasProvidersWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentSystemsHasProvidersColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentSystemsHasProvidersWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentSystemsHasProvidersWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentSystemsHasProvidersWhereHasConditionsRelation
}

# Allowed column names for Query.paymentSystems.hasProviders.
enum QueryPaymentSystemsHasProvidersColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasProviders` argument on the query `paymentSystems`.
input QueryPaymentSystemsHasProvidersWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentSystemsHasProvidersWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `paymentSystems`.
input QueryPaymentSystemsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryPaymentSystemsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentSystemsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentSystemsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentSystemsWhereWhereConditionsRelation
}

# Allowed column names for Query.paymentSystems.where.
enum QueryPaymentSystemsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `paymentSystems`.
input QueryPaymentSystemsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentSystemsWhereWhereConditions
}

# Order by clause for Query.paymentSystems.orderBy.
input QueryPaymentSystemsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryPaymentSystemsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.paymentSystems.orderBy.
enum QueryPaymentSystemsOrderByColumn {
  ID
  NAME
  IS_ACTIVE
}

# A paginated list of PaymentSystem items.
type PaymentSystemPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PaymentSystem items.
  data: [PaymentSystem!]!
}

# Dynamic WHERE conditions for the `hasCompanies` argument on the query `payments`.
input QueryPaymentsHasCompaniesWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentsHasCompaniesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsHasCompaniesWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsHasCompaniesWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentsHasCompaniesWhereHasConditionsRelation
}

# Allowed column names for Query.payments.hasCompanies.
enum QueryPaymentsHasCompaniesColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCompanies` argument on the query `payments`.
input QueryPaymentsHasCompaniesWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentsHasCompaniesWhereHasConditions
}

# Dynamic WHERE conditions for the `hasPaymentProvider` argument on the query `payments`.
input QueryPaymentsHasPaymentProviderWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentsHasPaymentProviderColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsHasPaymentProviderWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsHasPaymentProviderWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentsHasPaymentProviderWhereHasConditionsRelation
}

# Allowed column names for Query.payments.hasPaymentProvider.
enum QueryPaymentsHasPaymentProviderColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentProvider` argument on the query `payments`.
input QueryPaymentsHasPaymentProviderWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentsHasPaymentProviderWhereHasConditions
}

# Dynamic WHERE conditions for the `hasAccounts` argument on the query `payments`.
input QueryPaymentsHasAccountsWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentsHasAccountsColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsHasAccountsWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsHasAccountsWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentsHasAccountsWhereHasConditionsRelation
}

# Allowed column names for Query.payments.hasAccounts.
enum QueryPaymentsHasAccountsColumn {
  ACCOUNT_ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasAccounts` argument on the query `payments`.
input QueryPaymentsHasAccountsWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentsHasAccountsWhereHasConditions
}

# Dynamic WHERE conditions for the `hasOwner` argument on the query `payments`.
input QueryPaymentsHasOwnerWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentsHasOwnerColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsHasOwnerWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsHasOwnerWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentsHasOwnerWhereHasConditionsRelation
}

# Allowed column names for Query.payments.hasOwner.
enum QueryPaymentsHasOwnerColumn {
  FULLNAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasOwner` argument on the query `payments`.
input QueryPaymentsHasOwnerWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentsHasOwnerWhereHasConditions
}

# Dynamic WHERE conditions for the `hasPaymentOperation` argument on the query `payments`.
input QueryPaymentsHasPaymentOperationWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentsHasPaymentOperationColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsHasPaymentOperationWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsHasPaymentOperationWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentsHasPaymentOperationWhereHasConditionsRelation
}

# Allowed column names for Query.payments.hasPaymentOperation.
enum QueryPaymentsHasPaymentOperationColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentOperation` argument on the query `payments`.
input QueryPaymentsHasPaymentOperationWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentsHasPaymentOperationWhereHasConditions
}

# Dynamic WHERE conditions for the `hasPaymentUrgency` argument on the query `payments`.
input QueryPaymentsHasPaymentUrgencyWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentsHasPaymentUrgencyColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsHasPaymentUrgencyWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsHasPaymentUrgencyWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentsHasPaymentUrgencyWhereHasConditionsRelation
}

# Allowed column names for Query.payments.hasPaymentUrgency.
enum QueryPaymentsHasPaymentUrgencyColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentUrgency` argument on the query `payments`.
input QueryPaymentsHasPaymentUrgencyWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentsHasPaymentUrgencyWhereHasConditions
}

# Dynamic WHERE conditions for the `hasPaymentStatus` argument on the query `payments`.
input QueryPaymentsHasPaymentStatusWhereHasConditions {
  # The column that is used for the condition.
  column: QueryPaymentsHasPaymentStatusColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsHasPaymentStatusWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsHasPaymentStatusWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentsHasPaymentStatusWhereHasConditionsRelation
}

# Allowed column names for Query.payments.hasPaymentStatus.
enum QueryPaymentsHasPaymentStatusColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasPaymentStatus` argument on the query `payments`.
input QueryPaymentsHasPaymentStatusWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentsHasPaymentStatusWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `payments`.
input QueryPaymentsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryPaymentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPaymentsWhereWhereConditionsRelation
}

# Allowed column names for Query.payments.where.
enum QueryPaymentsWhereColumn {
  SENDER_BANK_ACCOUNT
  TYPE_ID
  URGENCY_ID
  STATUS
  PAYMENT_PROVIDER_ID
  COMPANY_ID
  ACCOUNT_ID
  PAYMENT_NUMBER
  SENDER_NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `payments`.
input QueryPaymentsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPaymentsWhereWhereConditions
}

# Order by clause for Query.payments.orderBy.
input QueryPaymentsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryPaymentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.payments.orderBy.
enum QueryPaymentsOrderByColumn {
  ID
  CREATED_AT
  AMOUNT
  FEE
  PAYMENT_NUMBER
}

# A paginated list of Payments items.
type PaymentsPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Payments items.
  data: [Payments!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `requisites`.
input QueryRequisitesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryRequisitesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryRequisitesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryRequisitesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryRequisitesWhereWhereConditionsRelation
}

# Allowed column names for Query.requisites.where.
enum QueryRequisitesWhereColumn {
  ACCOUNT_ID
  BANK_NAME
  ACCOUNT_NO
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `requisites`.
input QueryRequisitesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryRequisitesWhereWhereConditions
}

# Order by clause for Query.requisites.orderBy.
input QueryRequisitesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryRequisitesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.requisites.orderBy.
enum QueryRequisitesOrderByColumn {
  ID
}

# A paginated list of Requisites items.
type RequisitesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Requisites items.
  data: [Requisites!]!
}

# Dynamic WHERE conditions for the `hasGroupTypes` argument on the query `roles`.
input QueryRolesHasGroupTypesWhereHasConditions {
  # The column that is used for the condition.
  column: QueryRolesHasGroupTypesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryRolesHasGroupTypesWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryRolesHasGroupTypesWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryRolesHasGroupTypesWhereHasConditionsRelation
}

# Allowed column names for Query.roles.hasGroupTypes.
enum QueryRolesHasGroupTypesColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupTypes` argument on the query `roles`.
input QueryRolesHasGroupTypesWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryRolesHasGroupTypesWhereHasConditions
}

# Dynamic WHERE conditions for the `hasGroups` argument on the query `roles`.
input QueryRolesHasGroupsWhereHasConditions {
  # The column that is used for the condition.
  column: QueryRolesHasGroupsColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryRolesHasGroupsWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryRolesHasGroupsWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryRolesHasGroupsWhereHasConditionsRelation
}

# Allowed column names for Query.roles.hasGroups.
enum QueryRolesHasGroupsColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroups` argument on the query `roles`.
input QueryRolesHasGroupsWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryRolesHasGroupsWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `roles`.
input QueryRolesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryRolesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryRolesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryRolesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryRolesWhereWhereConditionsRelation
}

# Allowed column names for Query.roles.where.
enum QueryRolesWhereColumn {
  NAME
  GROUP_TYPE_ID
  COMPANY_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `roles`.
input QueryRolesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryRolesWhereWhereConditions
}

# Order by clause for Query.roles.orderBy.
input QueryRolesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryRolesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.roles.orderBy.
enum QueryRolesOrderByColumn {
  ID
  NAME
  DESCRIPTION
}

# A paginated list of Role items.
type RolePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Role items.
  data: [Role!]!
}

# Dynamic WHERE conditions for the `hasCompany` argument on the query `tickets`.
input QueryTicketsHasCompanyWhereHasConditions {
  # The column that is used for the condition.
  column: QueryTicketsHasCompanyColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTicketsHasCompanyWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTicketsHasCompanyWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryTicketsHasCompanyWhereHasConditionsRelation
}

# Allowed column names for Query.tickets.hasCompany.
enum QueryTicketsHasCompanyColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasCompany` argument on the query `tickets`.
input QueryTicketsHasCompanyWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryTicketsHasCompanyWhereHasConditions
}

# Dynamic WHERE conditions for the `hasDepartment` argument on the query `tickets`.
input QueryTicketsHasDepartmentWhereHasConditions {
  # The column that is used for the condition.
  column: QueryTicketsHasDepartmentColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTicketsHasDepartmentWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTicketsHasDepartmentWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryTicketsHasDepartmentWhereHasConditionsRelation
}

# Allowed column names for Query.tickets.hasDepartment.
enum QueryTicketsHasDepartmentColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasDepartment` argument on the query `tickets`.
input QueryTicketsHasDepartmentWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryTicketsHasDepartmentWhereHasConditions
}

# Dynamic WHERE conditions for the `hasPosition` argument on the query `tickets`.
input QueryTicketsHasPositionWhereHasConditions {
  # The column that is used for the condition.
  column: QueryTicketsHasPositionColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTicketsHasPositionWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTicketsHasPositionWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryTicketsHasPositionWhereHasConditionsRelation
}

# Allowed column names for Query.tickets.hasPosition.
enum QueryTicketsHasPositionColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasPosition` argument on the query `tickets`.
input QueryTicketsHasPositionWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryTicketsHasPositionWhereHasConditions
}

# Dynamic WHERE conditions for the `hasMember` argument on the query `tickets`.
input QueryTicketsHasMemberWhereHasConditions {
  # The column that is used for the condition.
  column: QueryTicketsHasMemberColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTicketsHasMemberWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTicketsHasMemberWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryTicketsHasMemberWhereHasConditionsRelation
}

# Allowed column names for Query.tickets.hasMember.
enum QueryTicketsHasMemberColumn {
  FULLNAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasMember` argument on the query `tickets`.
input QueryTicketsHasMemberWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryTicketsHasMemberWhereHasConditions
}

# Dynamic WHERE conditions for the `hasClient` argument on the query `tickets`.
input QueryTicketsHasClientWhereHasConditions {
  # The column that is used for the condition.
  column: QueryTicketsHasClientColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTicketsHasClientWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTicketsHasClientWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryTicketsHasClientWhereHasConditionsRelation
}

# Allowed column names for Query.tickets.hasClient.
enum QueryTicketsHasClientColumn {
  FULLNAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasClient` argument on the query `tickets`.
input QueryTicketsHasClientWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryTicketsHasClientWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `tickets`.
input QueryTicketsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryTicketsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTicketsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTicketsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryTicketsWhereWhereConditionsRelation
}

# Allowed column names for Query.tickets.where.
enum QueryTicketsWhereColumn {
  TITLE
  STATUS
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `tickets`.
input QueryTicketsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryTicketsWhereWhereConditions
}

# Order by clause for Query.tickets.orderBy.
input QueryTicketsOrderByRelationOrderByClause {
  # The column that is used for ordering.
  column: QueryTicketsOrderByColumn

  # The direction that is used for ordering.
  order: SortOrder!

  # Aggregate specification.
  company: QueryTicketsOrderByCompany

  # Aggregate specification.
  department: QueryTicketsOrderByDepartment
}

# Allowed column names for Query.tickets.orderBy.
enum QueryTicketsOrderByColumn {
  ID
}

# Aggregate specification for Query.tickets.orderBy.company.
input QueryTicketsOrderByCompany {
  # Always COUNT.
  aggregate: OrderByRelationAggregateFunction!
}

# Aggregate functions when ordering by a relation without specifying a column.
enum OrderByRelationAggregateFunction {
  # Amount of items.
  COUNT
}

# Aggregate specification for Query.tickets.orderBy.department.
input QueryTicketsOrderByDepartment {
  # Always COUNT.
  aggregate: OrderByRelationAggregateFunction!
}

# A paginated list of Ticket items.
type TicketPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Ticket items.
  data: [Ticket!]!
}

# A paginated list of TwoFactorAuthSettings items.
type TwoFactorAuthSettingsPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of TwoFactorAuthSettings items.
  data: [TwoFactorAuthSettings!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `users`.
input QueryUsersWhereWhereConditions {
  # The column that is used for the condition.
  column: UsersColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryUsersWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryUsersWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryUsersWhereWhereConditionsRelation
}

enum UsersColumn {
  ID
  FULLNAME
  COMPANY_ID
  EMAIL
  GROUP_ID
  GROUP_TYPE_ID
  ROLE_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `users`.
input QueryUsersWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryUsersWhereWhereConditions
}

# Order by clause for Query.users.orderBy.
input QueryUsersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryUsersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.users.orderBy.
enum QueryUsersOrderByColumn {
  ID
  EMAIL
  FULLNAME
}

# A paginated list of Users items.
type UsersPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Users items.
  data: [Users!]!
}

# Пользователи
# Roles->Users
type Users {
  id: ID

  # Имя участника
  first_name: String

  # Фамилия участника
  last_name: String

  # Email участника
  email: EMAIL

  # получить компанию
  company: Companies

  # Получить группу
  group: GroupRole

  # Полное имя
  fullname: String
}

type Mutation {
  # Создать лимит
  createAccountLimit(
    # ID account
    account_id: ID!

    # ID типа лимита
    commission_template_limit_type_id: ID!

    # ID направления платежа
    commission_template_limit_transfer_direction_id: ID!

    # Сумма лимита
    amount: Float!

    # ID валюты лимита
    currency_id: ID

    # ID периода лимита
    commission_template_limit_period_id: ID!

    # ID события лимита
    commission_template_limit_action_type_id: ID!

    # ID количество срабатываний лимита
    period_count: ID
  ): AccountLimit

  # Обновить лимит
  updateAccountLimit(
    # ID шаблона
    id: ID!

    # ID типа лимита
    commission_template_limit_type_id: ID

    # ID направления платежа
    commission_template_limit_transfer_direction_id: ID

    # Сумма лимита
    amount: Float

    # ID валюты лимита
    currency_id: ID

    # ID периода лимита
    commission_template_limit_period_id: ID

    # ID события лимита
    commission_template_limit_action_type_id: ID

    # количество срабатываний лимита
    period_count: Int
  ): AccountLimit

  # Удалить лимит
  deleteAccountLimit(id: ID!): AccountLimit

  # Создать аккаунт
  createAccount(input: InputAccount!): Accounts

  # Редактирование аккаунта
  updateAccount(id: ID!, input: InputAccount!): Accounts

  # Удалить аккаунт
  deleteAccount(id: ID!): Accounts

  # Создать аккаунт
  generateIban(id: ID!): Accounts

  # Создать частного пользователя
  createApplicantIndividual(
    # Имя
    first_name: String!

    # Фамилия
    last_name: String!

    # Отчество
    middle_name: String

    # email
    email: EMAIL!

    # Адрес сайта
    url: String

    # Телефон
    phone: String!

    # ID Страны
    country_id: ID!

    # ID языка
    language_id: ID

    # ID страны гражданства
    citizenship_country_id: ID

    # Штат / область
    state: String

    # Город
    city: String!

    # Адрес
    address: String!

    # Индекс
    zip: String

    # Национальность
    nationality: String

    # ID страны рождения
    birth_country_id: ID!

    # Штат/область рождения
    birth_state: String

    # Город рождения
    birth_city: String

    # Дата рождения
    birth_at: Date!

    # Пол
    sex: Sex!

    # Дополнительные поля для Personal info
    personal_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля блока контакты
    contacts_additional_fields: [AdditionalFieldInput]

    # ID статуса
    applicant_status_id: ID

    # ID состояния
    applicant_state_id: ID!

    # ID причины
    applicant_state_reason_id: ID

    # ID уровня рисков
    applicant_risk_level_id: ID

    # ID менеджера
    account_manager_member_id: ID!

    # ID компании
    company_id: ID!

    # Массив ID меток
    labels: [ID]

    # ID группа
    group_id: ID

    # Two factor auth
    two_factor_auth_id: ID

    # Пароль
    password: String

    # подтверждение пароля
    password_confirmation: String
  ): ApplicantIndividual

  # Редактирование частного пользователя
  updateApplicantIndividual(
    id: ID!

    # Имя
    first_name: String

    # Фамилия
    last_name: String

    # Отчество
    middle_name: String

    # email
    email: EMAIL

    # Адрес сайта
    url: String

    # Телефон
    phone: String

    # Верецифиорован телефон true/false
    is_verification_phone: Boolean

    # ID Страны
    country_id: ID

    # ID языка
    language_id: ID

    # ID страны гражданства
    citizenship_country_id: ID

    # Штат / область
    state: String

    # Город
    city: String

    # Адрес
    address: String

    # Индекс
    zip: String

    # Национальность
    nationality: String

    # ID страны рождения
    birth_country_id: ID

    # Штат/область рождения
    birth_state: String

    # Город рождения
    birth_city: String

    # Дата рождения
    birth_at: Date

    # Пол
    sex: Sex

    # Дополнительные поля Profile data
    profile_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля для Personal info
    personal_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля блока контакты
    contacts_additional_fields: [AdditionalFieldInput]

    # ID статуса
    applicant_status_id: ID

    # ID состояния
    applicant_state_id: ID

    # ID причины
    applicant_state_reason_id: ID

    # ID уровня рисков
    applicant_risk_level_id: ID

    # ID менеджера
    account_manager_member_id: ID

    # ID компании
    company_id: ID

    # Массив ID меток
    labels: [ID]

    # ID группы
    group_id: ID

    # Two factor auth
    two_factor_auth_id: ID

    # Пароль
    password: String

    # подтверждение пароля
    password_confirmation: String
  ): ApplicantIndividual

  # Установить пароль
  setApplicantIndividualPassword(
    id: ID!

    # пароль
    password: String!

    # подтверждение пароля
    password_confirmation: String!
  ): ApplicantIndividual

  # Удалит пользователя
  deleteApplicantIndividual(id: ID!): ApplicantIndividual

  # Создать applicant company
  createApplicantBankingAccess(
    # Applicant individual
    applicant_individual_id: ID!

    # Applicant company
    applicant_company_id: ID!

    # Member
    member_id: ID!

    # Может создать платеж
    can_create_payment: Boolean!

    # Может подписать платеж
    can_sign_payment: Boolean!

    # Contact administrator
    contact_administrator: Boolean!

    # Ежедневный лимит
    daily_limit: Float!

    # Ежемесячный лимит
    monthly_limit: Float!

    # Лимит операций
    operation_limit: Float!

    # Использованный лимит
    used_limit: Float
  ): ApplicantBankingAccess

  # Редактирование applicant company
  updateApplicantBankingAccess(
    id: ID!

    # Applicant individual
    applicant_individual_id: ID!

    # Applicant company
    applicant_company_id: ID!

    # Member
    member_id: ID!

    # Может создать платеж
    can_create_payment: Boolean!

    # Может подписать платеж
    can_sign_payment: Boolean!

    # Contact administrator
    contact_administrator: Boolean!

    # Ежедневный лимит
    daily_limit: Float!

    # Ежемесячный лимит
    monthly_limit: Float!

    # Лимит операций
    operation_limit: Float!

    # Использованный лимит
    used_limit: Float
  ): ApplicantBankingAccess

  # Удалить пользователя
  deleteApplicantBankingAccess(id: ID!): ApplicantBankingAccess

  # Создать applicant company
  createApplicantCompany(
    # Название
    name: String!

    # email
    email: EMAIL!

    # Адрес сайта
    url: String!

    # Телефон
    phone: String!

    # ID страны
    country_id: ID!

    # ID языка
    language_id: ID

    # Штат / область
    state: String

    # Город
    city: String!

    # Адрес
    address: String!

    # Адрес2
    address2: String

    # Адрес офиса
    office_address: String

    # Индекс
    zip: String

    # Дата регистрации
    reg_at: Date

    # Дата окончания регистрации
    expires_at: Date!

    # Налоговый номер
    tax: String

    # Регистрационный номер
    reg_number: String

    # Номер лицензии
    license_number: String

    # Тип компании
    company_type: String

    # Дополнительные поля
    company_info_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля блока контакты
    contacts_additional_fields: [AdditionalFieldInput]

    # ID типов бизнеса
    applicant_company_business_type_id: ID

    # ID статуса
    applicant_status_id: ID

    # ID состояния
    applicant_state_id: ID!

    # ID причины
    applicant_state_reason_id: ID

    # ID уровня рисков
    applicant_risk_level_id: ID

    # ID KYC level
    applicant_kyc_level_id: ID

    # ID менеджера
    account_manager_member_id: ID!

    # ID компании
    company_id: ID!

    # ID owner
    owner_id: ID

    # ID relation владельца
    owner_relation_id: ID!

    # ID position владельца
    owner_position_id: ID!

    # Массив ID меток
    labels: [ID]

    # ID группы
    group_id: ID
  ): ApplicantCompany

  # Редактирование applicant company
  updateApplicantCompany(
    id: ID!

    # Название
    name: String

    # email
    email: EMAIL

    # Адрес сайта
    url: String

    # Телефон
    phone: String

    # Верецифиорован телефон true/false
    is_verification_phone: Boolean

    # страна
    country_id: ID

    # ID языка
    language_id: ID

    # Штат / область
    state: String

    # Город
    city: String

    # Адрес
    address: String

    # Адрес2
    address2: String

    # Адрес офиса
    office_address: String

    # Индекс
    zip: String

    # Дата регистрации
    reg_at: Date

    # Дата окончания регистрации
    expires_at: Date

    # Налоговый номер
    tax: String

    # Регистрационный номер
    reg_number: String

    # Номер лицензии
    license_number: String

    # Тип компании
    company_type: String

    # Дополнительные поля Company Info
    company_info_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля блока контакты
    contacts_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля Profile data
    profile_additional_fields: [AdditionalFieldInput]

    # ID типа бизнеса
    applicant_company_business_type_id: ID

    # ID статуса
    applicant_status_id: ID

    # ID состояния
    applicant_state_id: ID

    # ID причины
    applicant_state_reason_id: ID

    # ID уровня рисков
    applicant_risk_level_id: ID

    # ID KYC level
    applicant_kyc_level_id: ID

    # ID менеджера
    account_manager_member_id: ID

    # ID компании
    company_id: ID

    # ID owner
    owner_id: ID

    # ID relation владельца
    owner_relation_id: ID

    # ID position владельца
    owner_position_id: ID

    # Массив ID меток
    labels: [ID]

    # ID группы
    group_id: ID
  ): ApplicantCompany

  # Удалить пользователя
  deleteApplicantCompany(id: ID!): ApplicantCompany

  # Добавить связь Individual с Company
  createApplicantIndividualCompany(
    applicant_individual_id: ID!
    applicant_company_id: ID!
    applicant_individual_company_relation_id: ID!
    applicant_individual_company_position_id: ID!
  ): ApplicantIndividualCompany

  # Редактировать связь Individual с Company
  updateApplicantIndividualCompany(
    applicant_individual_id: ID!
    applicant_company_id: ID!
    applicant_individual_company_relation_id: ID
    applicant_individual_company_position_id: ID
  ): ApplicantIndividualCompany

  # Удалить связь Individual с Company
  deleteApplicantIndividualCompany(
    applicant_individual_id: ID!
    applicant_company_id: ID!
  ): ApplicantIndividualCompany

  # Создать бизнес тип
  createApplicantCompanyBusinessType(
    # Название
    name: String!
  ): ApplicantCompanyBusinessType

  # Редактирование отнощения
  updateApplicantCompanyBusinessType(
    # ID бизнес типа
    id: ID!

    # Название
    name: String!
  ): ApplicantCompanyBusinessType

  # Создать метку
  createApplicantCompanyLabel(
    # Название метки
    name: String!

    # HEX код метки
    hex_color_code: String!
  ): ApplicantCompanyLabel

  # Редактирование метки
  updateApplicantCompanyLabel(
    # ID метки
    id: ID!

    # Название метки
    name: String!

    # HEX код метки
    hex_color_code: String
  ): ApplicantCompanyLabel

  # Удалит метку
  deleteApplicantCompanyLabel(
    id: ID!
    deleteAnyway: Boolean
  ): ApplicantCompanyLabel

  # Создать метку компании
  attachApplicantCompanyLabel(
    # Аппликант
    applicant_company_id: ID!

    # Метка
    applicant_company_label_id: [ID]
  ): ApplicantCompany

  # Удалить метку
  detachApplicantCompanyLabel(
    applicant_company_id: ID!
    applicant_company_label_id: [ID]
  ): ApplicantCompany

  # Создать модуль компании
  createApplicantCompanyModule(
    # Компания
    applicant_company_id: ID!

    # Модуль
    applicant_module_id: [ID]

    # Активный или неактивный
    is_active: Boolean
  ): ApplicantCompany

  # Активировать модуль applicant company
  updateApplicantCompanyModule(
    # Аппликант
    applicant_company_id: ID!

    # Модуль
    applicant_module_id: [ID]

    # Активный или неактивный
    is_active: Boolean
  ): ApplicantCompany

  # Удалить модуль
  deleteApplicantCompanyModule(
    applicant_company_id: ID!
    applicant_module_id: [ID]
  ): ApplicantCompany

  # Создать заметку
  createApplicantCompanyNote(
    # Текст заметки
    note: String!

    # ID пользователя
    applicant_company_id: ID!

    # ID автора заметки
    member_id: ID!
  ): ApplicantCompanyNotes

  # Удалит заметку
  deleteApplicantCompanyNote(id: ID!): ApplicantCompanyNotes

  # Создать уровень риска
  createApplicantCompanyRiskLevel(
    # Описание
    description: String!

    # ID пользователя
    applicant_company_id: ID!

    # ID автора
    member_id: ID!
  ): ApplicantCompanyRiskLevel

  # Удалит заметку
  deleteApplicantCompanyRiskLevel(id: ID!): ApplicantCompanyRiskLevel

  # Добавить запись
  createApplicantCompanyRiskLevelHistory(
    # Комментарий
    comment: String!

    # Аппликант
    applicant_company_id: ID!

    # Уровень риска
    risk_level_id: ID!
  ): ApplicantCompanyRiskLevelHistory

  # Удалить запись
  deleteApplicantCompanyRiskLevelHistory(
    id: ID!
  ): ApplicantCompanyRiskLevelHistory

  # Создать должность
  createApplicantIndividualCompanyPosition(
    # Название
    name: String!
  ): ApplicantIndividualCompanyPosition

  # Редактирование должности
  updateApplicantIndividualCompanyPosition(
    # ID должности
    id: ID!

    # Название
    name: String!
  ): ApplicantIndividualCompanyPosition

  # Создать отношение
  createApplicantIndividualCompanyRelation(
    # Название
    name: String!
  ): ApplicantIndividualCompanyRelation

  # Редактирование отнощения
  updateApplicantIndividualCompanyRelation(
    # ID отношения
    id: ID!

    # Название
    name: String!
  ): ApplicantIndividualCompanyRelation

  # Создать модуль аппликанта
  createApplicantIndividualModule(
    # Аппликант
    applicant_individual_id: ID!

    # Модуль
    applicant_module_id: [ID]

    # Активный или неактивный
    is_active: Boolean
  ): ApplicantIndividual

  # Активировать или деактивировать модуль аппликанту
  updateApplicantIndividualModule(
    # Аппликант
    applicant_individual_id: ID!

    # Модуль
    applicant_module_id: [ID]

    # Активный или неактивный
    is_active: Boolean
  ): ApplicantIndividual

  # Удалить модуль
  deleteApplicantIndividualModule(
    applicant_individual_id: ID!
    applicant_module_id: [ID]
  ): ApplicantIndividual

  # Создать уровень риска
  createApplicantIndividualRiskLevel(
    # Описание
    description: String!

    # ID пользователя
    applicant_individual_id: ID!

    # ID автора
    member_id: ID!
  ): ApplicantIndividualRiskLevel

  # Удалит заметку
  deleteApplicantIndividualRiskLevel(id: ID!): ApplicantCompanyRiskLevel

  # Добавить запись
  createApplicantRiskLevelHistory(
    # Комментарий
    comment: String!

    # Аппликант
    applicant_id: ID!

    # Уровень риска
    risk_level_id: ID!
  ): ApplicantRiskLevelHistory

  # Удалить запись
  deleteApplicantRiskLevelHistory(id: ID!): ApplicantRiskLevelHistory

  # Создать метку
  createApplicantIndividualLabel(
    # Название метки
    name: String!

    # HEX код метки
    hex_color_code: String!
  ): ApplicantIndividualLabel

  # Редактирование метки
  updateApplicantIndividualLabel(
    # ID метки
    id: ID!

    # Название метки
    name: String!

    # HEX код метки
    hex_color_code: String
  ): ApplicantIndividualLabel

  # Удалить метку
  deleteApplicantIndividualLabel(
    id: ID!
    deleteAnyway: Boolean
  ): ApplicantIndividualLabel

  # Создать метку аппликанту
  attachApplicantIndividualLabel(
    # Аппликант
    applicant_individual_id: ID!

    # Метка
    applicant_individual_label_id: [ID]
  ): ApplicantIndividual

  # Удалить метку
  detachApplicantIndividualLabel(
    applicant_individual_id: ID!
    applicant_individual_label_id: [ID]
  ): ApplicantIndividual

  # Создать модуль
  createApplicantModule(
    # Название модуля
    name: String!
  ): ApplicantModules

  # Создать заметку
  createApplicantIndividualNote(
    # Текст заметки
    note: String!

    # ID пользователя
    applicant_individual_id: ID!

    # ID автора заметки
    member_id: ID!
  ): ApplicantIndividualNotes

  # Удалит заметку
  deleteApplicantIndividualNote(id: ID!): ApplicantIndividualNotes

  # Создать причину
  createApplicantStateReason(
    # Название
    name: String!
  ): ApplicantStateReason

  # Редактирование причины
  updateApplicantStateReason(
    # ID метки
    id: ID!

    # Название
    name: String!
  ): ApplicantStateReason

  # Удалит метку
  deleteApplicantStateReason(id: ID!): ApplicantStateReason

  # Создание Business Activity
  createBusinessActivity(
    # Название
    name: String!
  ): BusinessActivity

  # Изменение Business Activity
  updateBusinessActivity(
    id: ID!

    # Название
    name: String!
  ): BusinessActivity

  # Создать прай лист
  createCommissionPriceList(
    # Название шаблона
    name: String!

    # ID платежного провайдера
    provider_id: ID!

    # ID платежной системы
    payment_system_id: ID!

    # ID платежного шаблона
    commission_template_id: ID!
  ): CommissionPriceList

  # Редактирование частного пользователя
  updateCommissionPriceList(
    id: ID!

    # Название шаблона
    name: String!

    # ID платежного провайдера
    provider_id: ID!

    # ID платежной системы
    payment_system_id: ID!

    # ID платежного шаблона
    commission_template_id: ID!
  ): CommissionPriceList

  # Удалить прайс лист
  deleteCommissionPriceList(id: ID!): CommissionPriceList

  # Создание шаблона комиссий
  createCommissionTemplate(
    # Название шаблона
    name: String!

    # Описание шаблона
    description: String

    # ID платежного провайдера
    payment_provider_id: ID!
  ): CommissionTemplate

  # Обновление полей шаблона комиссий
  updateCommissionTemplate(
    # ID шаблона
    id: ID!

    # Название шаблона
    name: String

    # Описание шаблона
    description: String

    # Активен или нет
    is_active: Boolean

    # ID платежного провайдера
    payment_provider_id: ID

    # массив ID бизнесов
    business_activity: [ID]

    # массив ID стран
    country_id: [ID]

    # массив ID валют
    currency_id: [ID]

    # массив ID лимитов
    commission_template_limit_id: [ID]
  ): CommissionTemplate

  # Удалить шаблон
  deleteCommissionTemplate(id: ID!): CommissionTemplate

  # Создать лимит
  createCommissionTemplateLimit(
    # ID типа лимита
    commission_template_limit_type_id: ID!

    # ID направления платежа
    commission_template_limit_transfer_direction_id: ID!

    # Сумма лимита
    amount: Float!

    # ID валюты лимита
    currency_id: ID

    # ID периода лимита
    commission_template_limit_period_id: ID!

    # ID события лимита
    commission_template_limit_action_type_id: ID!

    # ID количество срабатываний лимита
    period_count: ID

    # ID шаблона комиссии
    commission_template_id: ID!
  ): CommissionTemplateLimit

  # Обновить лимит
  updateCommissionTemplateLimit(
    # ID шаблона
    id: ID!

    # ID типа лимита
    commission_template_limit_type_id: ID

    # ID направления платежа
    commission_template_limit_transfer_direction_id: ID

    # Сумма лимита
    amount: Float

    # ID валюты лимита
    currency_id: ID

    # ID периода лимита
    commission_template_limit_period_id: ID

    # ID события лимита
    commission_template_limit_action_type_id: ID

    # количество срабатываний лимита
    period_count: Int

    # ID шаблона комиссии
    commission_template_id: ID!
  ): CommissionTemplateLimit

  # Удалить лимит
  deleteCommissionTemplateLimit(id: ID!): CommissionTemplateLimit

  # Создать компанию
  createCompany(
    # Название компании
    name: String!

    # Email компании
    email: EMAIL!

    # Сайт компании
    url: String

    # Индекс компании
    zip: String

    # Адрес компании
    address: String

    # Город компании
    city: String

    # Регистрационный номер компании
    company_number: String

    # Контактное имя
    contact_name: String

    # ID страны
    country_id: ID!
  ): Companies

  # Обновить данные компании
  updateCompany(
    # ID компании
    id: ID!

    # Название компании
    name: String

    # Email компании
    email: EMAIL

    # Сайт компании
    url: String

    # Индекс компании
    zip: String

    # Адрес компании
    address: String

    # Город компании
    city: String

    # Регистрационный номер компании
    company_number: String

    # ID страны
    country_id: ID

    # Контактное имя
    contact_name: String

    # Дополнительные поля
    additional_fields: [AdditionalFieldInput]
  ): Companies

  # Удалит компанию
  deleteCompany(id: ID!): Companies

  # Добавить настройки к компании
  createCompanySettings(
    # Client applicant URL в формате http://example.com
    email_url: String

    # JWT token
    email_jwt: String

    # Email отправителя клиента
    email_from: EMAIL

    # Показывать лого компании или нет
    show_own_logo: Boolean

    # ID компании
    company_id: Int!
  ): CompanySettings

  # Обновление настроек компании
  updateCompanySettings(
    # ID компании
    company_id: ID!

    # Client applicant URL в формате http://example.com
    email_url: String

    # JWT token
    email_jwt: String

    # Email отправителя клиента
    email_from: EMAIL

    # Показывать лого компании или нет
    show_own_logo: Boolean
  ): CompanySettings

  # Создать департамент
  createDepartment(
    # Название департамента
    name: String!

    # ID компании
    company_id: ID!

    # Массив названий должностей
    department_positions_name: [String]
  ): Departments

  # Изменить название департамента
  updateDepartment(
    # ID департамента
    id: ID!

    # ID активных должностей
    active_department_positions_id: [ID]
  ): Departments

  # Создание должности
  createDepartmentPosition(
    # Назвние должности
    name: String!

    # ID департамента
    department_id: ID

    # ID компании
    company_id: ID!
  ): DepartmentPosition

  # Удалить департамент
  deleteDepartment(id: ID!): Departments

  # Удалить должность
  deleteDepartmentPosition(id: ID!): DepartmentPosition

  # Создать электронную почту
  createEmailNotification(
    # Тип Группы
    group_type_id: ID!

    # Тип Group Role
    group_role_id: ID!

    # ID компании
    company_id: ID!

    # ID клиента тип унион
    client_id: Int

    # ID email templates
    templates: [Int]!
  ): EmailNotification

  # Обновить данные компании
  updateEmailNotification(
    id: ID!

    # Тип Группы
    group_type_id: ID!

    # Тип Group Role
    group_role_id: ID!

    # ID компании
    company_id: ID

    # ID клиента тип унион
    client_id: Int

    # ID email templates
    templates: [Int]
  ): EmailNotification

  # Удалить запись
  deleteEmailNotification(id: ID!): EmailNotification

  # Создать смтп
  createEmailSmtp(
    name: String!

    # Защита
    security: Securities

    # Имя хоста
    host_name: String!

    # От кого
    from_name: String

    # почта
    from_email: String

    # логин
    username: String!

    # пароль
    password: String!

    # ответить кому
    replay_to: String

    # Порт
    port: Int!

    # ID компании
    company_id: ID!

    # Определяем отправлять через данные настройки всю почту или нет
    is_sending_mail: Boolean
  ): EmailSmtp

  # Обновить данные смтп
  updateEmailSmtp(
    # Ид шаблона
    id: ID!

    # Защита
    security: Securities

    # Имя хоста
    host_name: String

    # От кого
    from_name: String

    # почта
    from_email: String

    # логин
    username: String

    # пароль
    password: String

    # ответить кому
    replay_to: String

    # Порт
    port: Int

    # Определяем отправлять через данные настройки всю почту или нет
    is_sending_mail: Boolean
  ): EmailSmtp

  # Удалить запись
  deleteEmailSmtp(
    # ID шаблона
    id: ID!
  ): [EmailSmtp!]!
  sendEmail(
    security: Securities

    # Имя хоста
    host_name: String!

    # От кого
    from_name: String

    # почта
    from_email: String

    # логин
    username: String!

    # пароль
    password: String!

    # ответить кому
    replay_to: String

    # Порт
    port: Int!

    # e-mail
    email: String!
  ): StatusType

  # Создать электронную почту
  createEmailTemplateLayout(
    header: String!

    # Footer электронной почты
    footer: String!

    # Ид компании
    company_id: Int!
  ): EmailTemplateLayout

  # Обновить данные компании
  updateEmailTemplateLayout(
    id: ID!

    # Header электронной почты
    header: String

    # Footer электронной почты
    footer: String

    # Ид компании
    company_id: Int!
  ): EmailTemplateLayout

  # Удалить запись
  deleteEmailTemplateLayout(id: ID!): EmailTemplateLayout

  # Создать электронную почту
  createEmailTemplate(
    # Название
    name: String!

    # Тема
    subject: String!

    # Взять layout
    use_layout: Boolean!

    # Тип электронной почты
    type: ClientType!

    # Тип сервиса
    service_type: ServiceType!

    # Контент электронной почты
    content: String!

    # Header электронной почты
    header: String

    # Footer электронной почты
    footer: String

    # Ид компании
    company_id: ID!
  ): EmailTemplate

  # Обновить данные компании
  updateEmailTemplate(
    id: ID!

    # Название
    name: String

    # Тема
    subject: String

    # Взять layout
    use_layout: Boolean

    # Тип электронной почты
    type: ClientType

    # Тип сервиса
    service_type: ServiceType

    # Контент электронной почты
    content: String

    # Header электронной почты
    header: String

    # Footer электронной почты
    footer: String

    # Ид компании
    company_id: ID
  ): EmailTemplate

  # Удалить запись
  deleteEmailTemplate(id: ID!): EmailTemplate
  sendEmailWithTemplate(
    # почта
    email: String!

    # Company Id
    company_id: ID!

    # Subject
    subject: String!

    # Content
    content: String

    # Header электронной почты
    header: String

    # Footer электронной почты
    footer: String
  ): StatusType

  # Удалить файл
  deleteFile(id: ID!): Files

  # Создать группу
  createGroupSettings(
    # Название группы
    name: String!

    # Описание группы
    description: String

    # ID роли
    role_id: ID

    # ID типа группы из списка групп поумолчанию
    group_type_id: ID!

    # ID платежного провайдера
    payment_provider_id: ID

    # ID шаблона комиссий
    commission_template_id: ID

    # Активная или нет группа (true/false)
    is_active: Boolean

    # ID компании
    company_id: ID
  ): GroupRole

  # Обновить поля группы
  updateGroupSettings(
    # ID группы
    id: ID!

    # Название группы
    name: String

    # Описание группы
    description: String

    # ID роли
    role_id: ID

    # ID типа группы из списка групп поумолчанию
    group_type_id: ID!

    # ID платежного провайдера
    payment_provider_id: ID

    # ID шаблона комиссий
    commission_template_id: ID

    # Активная или нет группа (true/false)
    is_active: Boolean

    # ID компании
    company_id: ID
  ): GroupRole

  # Удаление группы
  deleteGroup(id: ID!): GroupRole

  # Добавить группу мемберу
  setMemberGroup(
    # Group
    group_type_id: ID!

    # Payment Provider
    payment_provider_id: ID!

    # Commission Template
    commission_template_id: ID!

    # Роль
    role_id: ID!
  ): GroupRole

  # Создать ограничение доступа
  createMemberAccessLimitation(
    # ID Мембера
    member_id: ID!

    # ID Груп Роль
    group_role_id: ID!

    # ID платежный шаблон
    commission_template_id: ID
  ): MemberAccessLimitation

  # Обновить ограничение доступа
  updateMemberAccessLimitation(
    # ID Мембера
    member_id: ID!

    # ID Груп Роль
    group_role_id: ID!

    # ID платежный шаблон
    commission_template_id: ID
  ): MemberAccessLimitation

  # Удалить ограничение доступа
  deleteMemberAccessLimitation(
    # ID доступа
    id: ID!
  ): MemberAccessLimitation

  # Создать участника
  createMember(
    # Имя участника
    first_name: String!

    # Фамилия участника
    last_name: String!

    # Email участника
    email: EMAIL!

    # Пол участника
    sex: Sex

    # ID компании
    company_id: ID!

    # ID страны
    country_id: ID

    # ID языка
    language_id: ID

    # ID роли участника
    group_id: ID!

    # Активен не активен
    is_active: Boolean

    # ID настройки двухфактороной авторизации
    two_factor_auth_setting_id: ID!

    # Пароль участника, если не передан то сгенерируется случайный
    password: String

    # если true видит только своих аппликантов
    is_show_owner_applicants: Boolean

    # Подписывать или нет транзакцию
    is_sign_transaction: Boolean
  ): Members

  # Пригласить участника
  inviteMember(
    # Имя участника
    first_name: String!

    # Фамилия участника
    last_name: String!

    # Email участника
    email: EMAIL!

    # ID компании
    company_id: ID!

    # ID группы участника
    group_id: ID!

    # ID настройки двухфактороной авторизации
    two_factor_auth_setting_id: ID!
  ): Members

  # Обновить поля участника
  updateMember(
    # ID участника
    id: ID!

    # Имя участника
    first_name: String

    # Фамилия участника
    last_name: String

    # Email участника
    email: EMAIL

    # Пол участника
    sex: Sex

    # ID компании
    company_id: ID

    # ID страны
    country_id: ID

    # ID языка
    language_id: ID

    # ID роли участника
    group_id: ID

    # Активен не активен
    is_active: Boolean

    # ID должности
    department_position: ID

    # ID настройки двухфактороной авторизации
    two_factor_auth_setting_id: ID

    # Блок дополнительных полей
    # в формате:
    # {field_type:Тип поля, field_name: Название дополнительного поля, field_value: Значение поля}
    additional_fields: [AdditionalFieldInput]

    # Дополнительны поля для member info
    additional_info_fields: [AdditionalFieldInput]

    # если true видит только своих аппликантов
    is_show_owner_applicants: Boolean

    # Подписывать или нет транзакцию
    is_sign_transaction: Boolean

    # ip_address
    ip_address: String
  ): Members

  # Установить пароль участника
  setMemberPassword(
    id: ID!
    password: String!
    password_confirmation: String!
  ): Members

  # Установить PIN участнику
  setMemberSecurityPin(id: ID!): Members

  # Удалить участника
  deleteMember(
    # ID участника
    id: ID!
  ): Members

  # Создать платежный провайдер
  createPaymentProvider(
    # Название провайдера
    name: String!

    # Описание провайдера
    description: String

    # ключ для получения изображения в Object Storage
    logo_key: String

    # Активен или нет
    is_active: Boolean

    # массив ID платежных систем
    payment_systems: [ID]
  ): PaymentProvider

  # Обновить поля платежного провайдера
  updatePaymentProvider(
    id: ID!

    # Название провайдера
    name: String

    # Описание провайдера
    description: String

    # ключ для получения изображения в Object Storage
    logo_key: String

    # Активен или нет
    is_active: Boolean

    # массив ID платежных систем
    payment_systems: [ID]
  ): PaymentProvider

  # Удалить платежный провайдер
  deletePaymentProvider(id: ID!): PaymentProvider

  # Создать платежную систему
  createPaymentSystem(
    # Название платежной системы
    name: String!

    # Активный не активный (true/false)
    is_active: Boolean

    # массив ID стран
    countries: [ID]

    # массив ID валют
    currencies: [ID]

    # массив ID провайдеров
    providers: [ID]
  ): PaymentSystem

  # Обновить поля платежной системы
  updatePaymentSystem(
    # ID платежной системы
    id: ID!

    # Название платежной системы
    name: String

    # Активный не активный (true/false)
    is_active: Boolean

    # массив ID стран
    countries: [ID]

    # массив ID валют
    currencies: [ID]

    # массив ID провайдеров
    providers: [ID]
  ): PaymentSystem

  # Удалить платежную систему
  deletePaymentSystem(id: ID!): PaymentSystem

  # Создать платеж
  createPayment(
    # Сумма
    amount: Float!

    # Сумма реального зачисления
    amount_real: Float

    # Комиссия
    fee: Float
    fee_type_id: ID!

    # Валюта
    currency_id: ID!

    # Статус
    status_id: ID!

    # Имя отправителя
    sender_name: String!

    # Детали платежа
    payment_details: String!

    # Аккаунт банка отправителя
    sender_bank_account: String!

    # SWIFT отправителя
    sender_swift: String!

    # Имя банка отправителя
    sender_bank_name: String!

    # Страна банка отправителя
    sender_bank_country: ID!

    # Адрес банка отправителя
    sender_bank_address: String!

    # Страна отправителя
    sender_country_id: ID

    # Адрес отправителя
    sender_address: String

    # Срочность
    urgency_id: ID!

    # Тип
    operation_type_id: ID!

    # Платежный ровайдер
    payment_provider_id: ID!

    # Аккаунт
    account_id: ID!

    # Компания
    company_id: ID!

    # Кто делает пеймент
    owner_id: ID!

    # Номер платежа
    payment_number: String!

    # Error
    error: String
    created_at: DateTime
    updated_at: DateTime
    received_at: DateTime
  ): Payments

  # Редактировать платеж
  updatePayment(
    id: ID!

    # Сумма
    amount: Float

    # Комиссия
    fee: Float

    # Валюта
    currency: ID

    # Статус
    status: Int

    # Имя отправителя
    sender_name: String

    # Детали платежа
    payment_details: String

    # Аккаунт банка отправителя
    sender_bank_account: String

    # SWIFT отправителя
    sender_swift: String

    # Имя банка отправителя
    sender_bank_name: String

    # Страна банка отправителя
    sender_bank_country: ID

    # Адрес банка отправителя
    sender_bank_address: String

    # Страна отправителя
    sender_country: ID

    # Адрес отправителя
    sender_address: String

    # Срочность
    urgency_id: ID!

    # Тип
    operation_type_id: ID!

    # Платежный ровайдер
    payment_provider_id: ID

    # Аккаунт
    account_id: ID

    # Компания
    company_id: ID

    # Номер платежа
    payment_number: String
  ): Payments

  # Удалить платеж
  deletePayment(id: ID!): Payments

  # Создать Цен
  createPriceListFees(
    # Название
    name: String

    # Тип
    type_id: Int

    # Тип операции
    operation_type_id: Int

    # Период
    period_id: Int

    # ID Прайс лист
    price_list_id: Int!
    fee: [[Fee]]
  ): PriceListFee

  # Обновить данные Цен
  updatePriceListFees(
    id: ID!

    # Название
    name: String

    # Тип
    type_id: Int

    # Тип операции
    operation_type_id: Int

    # Период
    period_id: Int
    fee: [[Fee]]
  ): PriceListFee

  # Удалить Цен
  deletePriceListFees(
    # ID price list fee
    id: ID!
  ): PriceListFee

  # Создать реквизиты
  createRequisites(
    # Получить связанный аккаунт
    account_id: ID!

    # Получатель
    recipient: String!

    # Registration Number
    registration_number: Int!

    # Адрес
    address: String!

    # Получить связанную страну
    country_id: ID!

    # Название банка
    bank_name: String!

    # Адрес банка
    bank_address: String!

    # Получить связанную страну банка
    bank_country_id: ID!

    # IBAN
    iban: String!

    # Номер аккаунта
    account_no: String!

    # SWIFT
    swift: String!

    # Банк корреспондент
    bank_correspondent: JSON
    created_at: DateTime
    updated_at: DateTime
  ): Requisites

  # Редактировать реквизиты
  updateRequisites(
    id: ID!

    # Получить связанный аккаунт
    account_id: ID

    # Получатель
    recipient: String

    # Registration Number
    registration_number: Int

    # Адрес
    address: String

    # Получить связанную страну
    country_id: ID

    # Название банка
    bank_name: String

    # Адрес банка
    bank_address: String

    # Получить связанную страну банка
    bank_country_id: ID

    # IBAN
    iban: String

    # Номер аккаунта
    account_no: String

    # SWIFT
    swift: String

    # Банк корреспондент
    bank_correspondent: JSON
    created_at: DateTime
    updated_at: DateTime
  ): Requisites

  # Удалить реквизиты
  deleteRequisites(id: ID!): Requisites
  createRole(
    # Название роли
    name: String!

    # Описание
    description: String

    # Массив разрешений
    permissions: [ID]

    # Тип группы
    group_type_id: ID

    # ID компании
    company_id: ID

    # ID группы полномочий Применить ко всем компаниям
    permission_category_all_member: [ID]
  ): Role
  updateRole(
    # ID роли
    id: ID!

    # Название роли
    name: String!

    # Описание роли
    description: String

    # Массив разрешений
    permissions: [ID]

    # Тип группы
    group_type_id: ID

    # ID компании
    company_id: ID

    # ID группы полномочий Применить ко всем компаниям
    permission_category_all_member: [ID]
  ): Role
  deleteRole(
    # ID роли
    id: ID!
  ): Role

  # Создать комментарии
  createTicketComment(
    # Сообщение
    message: String!

    # ID билета
    ticket_id: ID!

    # ID клиента
    client_id: ID!
  ): TicketComments

  # Создать компанию
  createTicket(
    # Название билета
    title: String!

    # Message билета
    message: String!

    # Статус билета
    status: Int

    # ID мембера
    company_id: ID!

    # ID клиента
    client_id: ID!
  ): Ticket

  # Обновить данные компании
  updateTicket(
    id: ID!

    # Статус билета
    status: Int!
  ): Ticket
}

input InputAccount {
  # ID компании
  company_id: ID!

  # ID валюты
  currency_id: ID!

  # ID аппликанта
  client_id: ID!

  # ID владельца
  owner_id: ID!

  # Номер аккаунта
  account_number: String

  # Тип аккаунта
  account_type: AccountType

  # ID провайдера
  payment_provider_id: ID!

  # ID шаблона комиссии
  commission_template_id: ID!

  # Состояние аккаунта
  account_state_id: ID!

  # Имя аккаунта
  account_name: String!

  # Основной или нет
  is_primary: Boolean

  # ID групроле
  group_role_id: ID!

  # ID группы
  group_type_id: ID!

  # ID платежной системы
  payment_system_id: ID!
}

# Дополнительные поля
input AdditionalFieldInput {
  field_name: String
  field_value: StringInteger
  field_type: FieldTypes
}

# String or Integer type
scalar StringInteger

# Типы полей
enum FieldTypes {
  # Тип поля строка
  Text

  # Тип поля текстовое поле
  TextArea

  # ID страны
  CountryList
}

type StatusType {
  status: String!
  message: String
}

input Fee {
  fee_from: StringInteger
  fee_to: StringInteger
  mode: FeeMode
  fee: StringInteger
  currency: [String]
}

enum FeeMode {
  Fix
  Range
  Percent
}

enum QueryAccountWhereColumn {
  ACCOUNT_NUMBER
  ACCOUNT_TYPE
  ACCOUNT_STATE_ID
  CLIENT_ID
  OWNER_ID
  ACCOUNT_NAME
  CURRENCY_ID
  PAYMENT_PROVIDER_ID
  COMPANY_ID
  GROUP_ROLE_ID
  GROUP_TYPE_ID
  MEMBER_ID
  IS_PRIMARY
  COMMISSION_TEMPLATE_ID
}

type Groups {
  id: ID!

  # Название группы
  name: GroupsEntities!
  groups: [GroupRole] @deprecated
}

type PermissionCategoryRole {
  permission_category_id: ID
  role_id: ID
  is_all_companies: Boolean
}

# Information about pagination using a simple paginator.
type SimplePaginatorInfo {
  # Number of items in the current page.
  count: Int!

  # Index of the current page.
  currentPage: Int!

  # Index of the first item in the current page.
  firstItem: Int

  # Index of the last item in the current page.
  lastItem: Int

  # Number of items per page.
  perPage: Int!

  # Are there more pages after this one?
  hasMorePages: Boolean!
}

# Information about pagination using a Relay style cursor connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # The cursor to continue paginating backwards.
  startCursor: String

  # The cursor to continue paginating forwards.
  endCursor: String

  # Total number of nodes in the paginated connection.
  total: Int!

  # Number of nodes in the current page.
  count: Int!

  # Index of the current page.
  currentPage: Int!

  # Index of the last available page.
  lastPage: Int!
}

# Dynamic WHERE conditions for queries.
input WhereConditions {
  # The column that is used for the condition.
  column: String

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [WhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [WhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: WhereConditionsRelation
}

# Dynamic HAS conditions for WHERE condition queries.
input WhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: WhereConditions
}

# Aggregate functions when ordering by a relation that may specify a column.
enum OrderByRelationWithColumnAggregateFunction {
  # Average.
  AVG

  # Minimum.
  MIN

  # Maximum.
  MAX

  # Sum.
  SUM

  # Amount of items.
  COUNT
}

# Allows ordering a list of records.
input OrderByClause {
  # The column that is used for ordering.
  column: String!

  # The direction that is used for ordering.
  order: SortOrder!
}
